
<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>PRECSS - Manage your CSS with prefixes.</title>
  <meta name="description" content="PRECSS is a new modular architecture approach based on OOCSS, SMACSS and BEM.">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta property="og:type" content="website" />
  <meta property="og:site_name" content="PRECSS - Manage your CSS with prefixes." />
  <meta property="og:url" content="https://precss.io/" />
  <meta property="og:image" content="https://precss.io/images/ogimage.png" />
  <meta property="og:description" content="PRECSS is a new modular architecture approach based on OOCSS, SMACSS and BEM." />
  <meta name="twitter:card" content="summary_large_image" />
  <meta name="twitter:title" content="PRECSS - Manage your CSS with prefixes." />
  <meta name="twitter:domain" content="precss.io">
  <meta name="twitter:image" content="https://precss.io/images/ogimage.png" />
  <meta name="twitter:description" content="PRECSS is a new modular architecture approach based on OOCSS, SMACSS and BEM.">
  <link rel="preload" href="/css/main.css" as="style">
  <link rel="shortcut icon" href="/images/favicon.ico" />
  <link rel="stylesheet" href="/css/main.css">
  <script defer src="//use.fontawesome.com/releases/v5.0.9/js/all.js" integrity="sha384-8iPTk2s/jMVj81dnzb/iFR2sdA7u06vHJyyLlAd4snFpCl/SnyUjRrbdJsw1pGIl" crossorigin="anonymous"></script>
  <script defer src="/js/jquery-3.4.1.min.js"></script>
  <script defer src="/js/scripts.js"></script>
  <script>
    function resizeIframe(obj) {
      obj.style.height = obj.contentWindow.document.documentElement.scrollHeight + 'px';
    }
  </script>
</head>
<body>
  <header class="ly_header">
    <div class="ly_header_inner">
      <nav class="bl_headerConts">
        <a class="bl_headerConts_logo" href="/"><img src="/images/logo.svg" alt="PRECSS"></a>
        <ul class="bl_headerConts_nav">
          <li><a title="Twitter" href="//twitter.com/assialiholic" target="_blank" rel="noopener"><i class="fab fa-twitter" aria-hidden="true"></i></a></li>
          <li><a title="GitHub" href="//github.com/assialiholic/precss/" target="_blank" rel="noopener"><i class="fab fa-github" aria-hidden="true"></i></a></li>
        </ul>
      </nav>
    </div>
    <!-- /.ly_header_inner -->
  </header>
  <article>
    <main>
      <section class="bl_MV">
        <div class="bl_MV_inner">
          <h1 class="bl_MV_ttl">Manage your CSS<br>with prefixes.</h1>
          <!-- <p class="bl_MV_img"><img src="/images/MV.png" alt=""></p> -->
          <pre class="bl_MV_code js_split">
            &lt;header class="<span class="hp_cBlue">ly_header</span>"&gt;...&lt;/header&gt;&nbsp;&nbsp;<span class="hp_cGray hp_fsi">&lt;!-- layout --&gt;</span>
            &lt;main class="<span class="hp_cBlue">ly_cont</span>"&gt;
                &lt;div class="<span class="hp_cGreen">bl_jumbotron</span>"&gt;&nbsp;&nbsp;<span class="hp_cGray hp_fsi">&lt;!-- block module --&gt;</span>
                    &lt;h2 class="<span class="hp_cGreen">bl_jumbotron_ttl</span>"&gt;PRECSS&lt;/h2&gt;
                    &lt;p class="<span class="hp_cGreen">bl_jumbotron_txt</span> <span class="hp_cViolet">hp_mb20</span>"&gt;CSS with prefixes.&lt;/p&gt;&nbsp;&nbsp;<span class="hp_cGray hp_fsi">&lt;!-- helper --&gt;</span>
                &lt;/div&gt;
            &lt;/main&gt;
            &lt;aside class="<span class="hp_cBlue">ly_side</span>"&gt;
                &lt;a href="#" class="<span class="hp_cOrange">el_btn</span>"&gt;Try PRECSS&lt;/a&gt;&nbsp;&nbsp;<span class="hp_cGray hp_fsi">&lt;!-- element module --&gt;</span>
                &lt;a href="#" class="<span class="hp_cOrange">el_btn</span> <span class="hp_cRed">el_btn__blue</span>"&gt;Back&lt;/a&gt;&nbsp;&nbsp;<span class="hp_cGray hp_fsi">&lt;!-- modifier --&gt;</span>
            &lt;/aside&gt;
            &lt;footer class="<span class="hp_cBlue">ly_footer</span>"&gt;...&lt;/footer&gt;
          </pre>
        </div>
        <!-- /.bl_MV_inner -->
      </section>
      <!-- /.bl_MV -->
      <div class="ly_cont">
        <div class="bl_sect">
          <div class="bl_catch">
            <p class="bl_catch_head">OOCSSやSMACSS、BEMの素晴らしさ巧みに取り入れ<br>更に進化させた強力なモジュール設計。それがPRECSSです。</p>
          </div>
          <!-- /.bl_catch -->
          <div class="bl_featureUnit bl_featureUnit__col2">
            <dl class="bl_featureBlock">
              <dt><i class="fas fa-sort-alpha-down hp_fz1_5e" aria-hidden="true"></i><br>全てに接頭辞を付加</dt>
              <dd>
                PRECSSの管理下にあるクラスは、全て種類に応じた接頭辞が付加されます。これにより接頭辞を一目見ただけで役割、スコープを把握することができます。<br>
                もうモジュールの粒度に悩まないでください。
              </dd>
            </dl>
            <dl class="bl_featureBlock">
              <dt><i class="fa fa-check-circle hp_fz1_3e" aria-hidden="true"></i><br>シンプルな命名規則</dt>
              <dd>
                クラス名は全てスネークケースとキャメルケースの混成で構成され、それらの使い分けには明確なルールがあります。<br>
                省略語についても指針を示しているため、今までのように悩んだあげく、とても長い名前を付ける必要はもうありません。
              </dd>
            </dl>
          </div>
          <!-- /.bl_featureUnit -->
          <div class="bl_featureUnit bl_featureUnit__col3">
            <dl class="bl_featureBlock">
              <dt><i class="fa fa-heart hp_fz1_3e" aria-hidden="true"></i><br>親しみやすい設計</dt>
              <dd>
                PRECSSは全く新しい設計思想ではありません。OOCSSやSMACSS、BEMなど今までの賞賛すべき素晴らしい思想が基になっています。<br>どれか1つでも知っていれば、PRECSSは親しみやすいものに感じるでしょう。
              </dd>
            </dl>
            <dl class="bl_featureBlock">
              <dt><i class="fa fa-users hp_fz1_5e" aria-hidden="true"></i><br>他種族との共存</dt>
              <dd>
                明確な独自記法により、あなたが書いたクラスとCMSやCSSフレームワークが出力したクラスを明確に区別することができます。<br>
                全てPRECSSのルールに従わなければならないのではなく、他の者も受け入れる柔軟さがPRECSSにはあります。
              </dd>
            </dl>
            <dl class="bl_featureBlock">
              <dt><i class="fas fa-expand-arrows-alt hp_fz1_3e" aria-hidden="true"></i><br>拡張可能</dt>
              <dd>
                スマートフォンなどスクリーンサイズの狭い場合のみに有効なクラスが必要になった場合は、「.sm_**」という接頭辞を持つグループを作るのもよいでしょう。<br>
                PRECSSは基本的にそれぞれ独自の接頭辞を持つ6つのグループから成り立っていますが、必要に応じて拡張も可能です。
              </dd>
            </dl>
          </div>
          <!-- /.bl_featureUnit bl_featureUnit__col3 -->
        </div>
        <!-- /.bl_sect -->
      </div>
      <!-- /.ly_body -->
      <nav class="ly_stickySide js_stickySide js_closeParent">
        <div class="js_stickyInner">
          <h2 class="el_smallTtl">目次</h2>
          <button type="button" class="el_closeBtn js_closeBtn">×</button>
          <h3 class="el_smallTtl2">Basics</h3>
          <ol class="bl_stickyList">
            <li>
              <a href="#rule">記法</a>
              <ol class="bl_simpleList02">
                <li><a href="#code-style">コーディングスタイル</a></li>
                <li><a href="#div">divの終了タグにはなるべくコメントを</a></li>
              </ol>
            </li>
            <li><a href="#nameRule">命名規則</a>
              <ol class="bl_simpleList02">
                <li><a href="#nameRule_general">汎用的に使用可能な名前</a></li>
                <li><a href="#nameRule_omission">単語を省略する場合</a></li>
                <li><a href="#nameRule_series">シリーズを形成する場合</a></li>
              </ol>
            </li>
          </ol>
          <h3 class="el_smallTtl2">Documentation</h3>
          <ol class="bl_stickyList">
            <li><a href="#base">ベース</a></li>
            <li><a href="#layout">レイアウト</a></li>
            <li>
              <a href="#block">ブロックモジュール</a>
              <ol class="bl_simpleList02">
                <li><a href="#block_applicable">適用可能なスタイル</a></li>
                <li><a href="#block_nameSize">概念・命名の粒度</a></li>
              </ol>
            </li>
            <li>
              <a href="#element">エレメントモジュール</a>
              <ol class="bl_simpleList02">
                <li><a href="#element_layout">レイアウトについて</a></li>
              </ol>
            </li>
            <li>
              <a href="#modifier">モディファイア</a>
              <ol class="bl_simpleList02">
                <li><a href="#modifier_element">エレメントモジュールの例</a></li>
                <li><a href="#modifier_block">ブロックモジュールの例</a></li>
              </ol>
            </li>
            <li>
              <a href="#helper">ヘルパー</a>
              <ol class="bl_simpleList02">
                <li><a href="#helper_clearfix">clearfixについて</a></li>
              </ol>
            </li>
            <li><a href="#unique">ユニーク</a></li>
            <li><a href="#program">プログラム</a></li>
            <li><a href="#original">オリジナル</a></li>
          </ol>
          <h3 class="el_smallTtl2">Advance</h3>
          <ol class="bl_stickyList">
            <li>
              <a href="#nestedModule">モジュールが他のモジュールにネストされる場合</a>
              <ol class="bl_simpleList02">
                <li><a href="#principal">原則1. 埋め込まれたモジュールのレイアウトは、コンテキストから制御する</a></li>
                <li><a href="#principal2">原則2. 埋め込まれたモジュール内の子要素は、コンテキストから制御してはならない</a></li>
              </ol>
            </li>
          </ol>
          <ul class="bl_iconList">
            <li><a title="Twitter" href="//twitter.com/assialiholic" target="_blank" rel="noopener"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
            <li><a title="GitHub" href="//github.com/assialiholic/precss/" target="_blank" rel="noopener"><i class="fab fa-github fa-lg" aria-hidden="true"></i></a></li>
          </ul>
        </div>
        <!-- /.js_stickyInner -->
      </nav>
      <!-- /.ly_stickySide -->

      <div class="bl_sectBlockCalm">
        <p class="bl_sectBlockCalm_txt">Basics</p>
      </div>
          <!-- /.bl_sectBlockCalm -->

      <div class="ly_cont">
        <section class="bl_sect bl_wysiwyg">
          <p>PRECSSはCSSの設計手法ではありますが、実際のプロジェクトで定義されるコーディング規約のなるべく多くをカバーするため、コードの書き方やクラス名に使用する単語の指針についても言及しています。</p>
          <h2 id="rule" class="el_lv2Heading">記法</h2>
          <h3 id="code-style" class="el_lv3Heading">コーディングスタイル</h3>
          <p>
            CSSの記述方法それ自体については、基本的に<a href="https://google.github.io/styleguide/htmlcssguide.html" target="_blank" rel="noopener">Google HTML/CSS Style Guide</a>、<a href="https://github.com/necolas/idiomatic-css" target="_blank" rel="noopener">Principles of writing consistent, idiomatic CSS</a>に則ることを推奨します。これはなるべく世界的に有名な規則を採用することで、コードが他人や他社に渡ってもなるべく差異が出ないことを目的としています。
          </p>
          <h3 id="div" class="el_lv3Heading">divの終了タグにはなるべくコメントを</h3>
          <p>
            div要素を使用する際は、なるべく終了タグに対応するクラス名を記載した閉じコメントを付けることを推奨します。これはdiv要素のネストが深くなったり、また何らかの理由でインデントが崩れた際にどの開始タグに対応するのかを把握しやすくするためです。<br>
            手動でコメントを追加するのは手間ですが、Emmetで展開前の文字列の末尾に「<code>|c（半角のパイプと小文字のc）</code>」と付けて展開することにより、自動的にクラス名に対応したコメントを終了タグの後に出力できます。
          </p>
          
          
  <div class="bl_codeBlock">
    <em class="bl_codeBlock_ttl"></em>
    <pre class="brush:html; class-name:'light'; highlight:[]">
      
            .hoge|c

            ↓ Emmetで展開

            &lt;div class=&#34;hoge&#34;&gt;
              ...
            &lt;/div&gt;
            &lt;!-- /.hoge --&gt;
            
    </pre>
  </div>
  <!-- /.bl_codeBlock -->

          <div id="nameRule" class="bl_sectBlock">
            <h2 class="el_lv2Heading">命名規則</h2>
            <p>
              PRECSSでは、意図的に記述する全てのクラスに種類に応じた2文字の接頭辞を付加します。<br>
              接頭辞及び単語間はモジュールの構造に基づきスネークケースで結合し、1つの構造内に複数の単語がある場合はその部分のみキャメルケースを使用します。つまりPRECSSにおいてアンダースコアは、構造的な階層を表す役割を担っています。<br>
              基本的にIDセレクタは使用せず、クラスセレクタを使用します。
            </p>
            
            
  <div class="bl_codeBlock">
    <em class="bl_codeBlock_ttl">×（単語の結合にハイフン・アンダースコアを使用している）</em>
    <pre class="brush:html; class-name:'light'; highlight:[]">
      
              &lt;!-- 単語をハイフンで結合した悪例 --&gt;
              &lt;div class=&#34;bl_half-media&#34;&gt;
                &lt;img class=&#34;bl_half-media_img&#34;&gt;
                &lt;div class=&#34;bl_half-media_desc&#34;&gt;
                  ...
                &lt;/div&gt;
                &lt;!-- /.bl_half-media_desc --&gt;
              &lt;/div&gt;
              &lt;!-- /.bl_half-media --&gt;

              &lt;!-- 単語をアンダースコアで結合した悪例 --&gt;
              &lt;div class=&#34;bl_half_media&#34;&gt;
                &lt;img class=&#34;bl_half_media_img&#34;&gt;
                &lt;div class=&#34;bl_half_media_desc&#34;&gt;
                  ...
                &lt;/div&gt;
                &lt;!-- /.bl_half_media_desc --&gt;
              &lt;/div&gt;
              &lt;!-- /.bl_half_media --&gt;
    </pre>
  </div>
  <!-- /.bl_codeBlock -->

            
            
  <div class="bl_codeBlock">
    <em class="bl_codeBlock_ttl">○ アンダースコアは構造を表すのに使用し、複数単語はキャメルケースを用いている</em>
    <pre class="brush:html; class-name:''; highlight:[]">
      
              &lt;div class=&#34;bl_halfMedia&#34;&gt;
                &lt;img class=&#34;bl_halfMedia_img&#34;&gt;
                &lt;div class=&#34;bl_halfMedia_desc&#34;&gt;
                  ...
                &lt;/div&gt;
                &lt;!-- /.bl_halfMedia_desc --&gt;
              &lt;/div&gt;
              &lt;!-- /.bl_halfMedia --&gt;
    </pre>
  </div>
  <!-- /.bl_codeBlock -->

            <p>
              また各モジュールの子要素は、基本的にモジュールのルート要素の名前のみを継承し、アンダースコアの後に子要素の名前を続けます。例えば子要素の中に子要素がネストされている際も、ネストされている子要素はあくまでルート要素の名前のみを継承します。
            </p>
            
            
  <div class="bl_codeBlock">
    <em class="bl_codeBlock_ttl">○ モジュールのルート要素の名前のみを継承した例</em>
    <pre class="brush:html; class-name:''; highlight:[]">
      
              &lt;div class=&#34;bl_halfMedia&#34;&gt;
                &lt;img class=&#34;bl_halfMedia_img&#34;&gt;
                &lt;div class=&#34;bl_halfMedia_desc&#34;&gt;
                  &lt;h3 class=&#34;bl_halfMedia_ttl&#34;&gt; ... &lt;/h3&gt;
                  &lt;p class=&#34;bl_halfMedia_txt&#34;&gt; ... &lt;/p&gt;
                &lt;/div&gt;
                &lt;!-- /.bl_halfMedia_desc --&gt;
              &lt;/div&gt;
              &lt;!-- /.bl_halfMedia --&gt;
    </pre>
  </div>
  <!-- /.bl_codeBlock -->

            <p>
              ただし、
            </p>
            <ul>
              <li>親子関係を意図をもって明確に定義したい</li>
              <li>モジュールが大きいため、子要素の名前の重複を避けたい</li>
            </ul>
            <p>
              のいずれかに該当する場合は、 ネストされた子要素のクラス名に直近の親要素の名前を含めることも許容します。
            </p>
            
            
  <div class="bl_codeBlock">
    <em class="bl_codeBlock_ttl">○ ネストされた子要素が直近の親要素の名前も継承している例</em>
    <pre class="brush:html; class-name:''; highlight:[]">
      
              &lt;div class=&#34;bl_halfMedia&#34;&gt;
                &lt;img class=&#34;bl_halfMedia_img&#34;&gt;
                &lt;div class=&#34;bl_halfMedia_desc&#34;&gt;
                  &lt;!-- ○ 「bl_halfMedia_desc」を継承 --&gt;
                  &lt;h3 class=&#34;bl_halfMedia_desc_ttl&#34;&gt; ... &lt;/h3&gt;
                  &lt;!-- ○ 「bl_halfMedia_desc」を継承 --&gt;
                  &lt;p class=&#34;bl_halfMedia_desc_txt&#34;&gt; ... &lt;/p&gt;
                &lt;/div&gt;
                &lt;!-- /.bl_halfMedia_desc --&gt;
              &lt;/div&gt;
              &lt;!-- /.bl_halfMedia --&gt;
    </pre>
  </div>
  <!-- /.bl_codeBlock -->

          </div>
          <!-- /.bl_sectBlock -->

          <h3 id="nameRule_general" class="el_lv3Heading">汎用的に使用可能な名前</h3>
          <ul>
            <li>_wrapper</li>
            <li>_inner</li>
            <li>_header</li>
            <li>_body</li>
            <li>_footer</li>
          </ul>
          <p>
            これらは後述する5つのグループいずれにおいても、必要に応じて汎用的に使用することができます。<br>
            _wrapperはモジュールのルート要素の親クラスとして使用することを想定しており、子要素ではありませんが「そのモジュールに属する」として、子要素と同じようにアンダースコアで結合します。
          </p>
          
          
  <div class="bl_codeBlock">
    <em class="bl_codeBlock_ttl">○ 汎用的な名前の使用例</em>
    <pre class="brush:html; class-name:''; highlight:[]">
      
            &lt;div class=&#34;bl_halfMedia_wrapper&#34;&gt;
              &lt;div class=&#34;bl_halfMedia&#34;&gt;
                &lt;div class=&#34;bl_halfMedia_inner&#34;&gt;
                  &lt;div class=&#34;bl_halfMedia_header&#34;&gt;
                    ...
                  &lt;/div&gt;
                  &lt;!-- /.bl_halfMedia_header --&gt;
                &lt;/div&gt;
                &lt;!-- /.bl_halfMedia_inner --&gt;
              &lt;/div&gt;
              &lt;!-- /.bl_halfMedia --&gt;
            &lt;/div&gt;
            &lt;!-- /.bl_halfMedia_wrapper --&gt;
    </pre>
  </div>
  <!-- /.bl_codeBlock -->


          <h3 id="nameRule_omission" class="el_lv3Heading">単語を省略する場合</h3>
          <p>
            各モジュールに独自の名前を持たせる設計は非常に素晴らしいアイディアですが、命名が冗長になってしまうのは避けられない問題です。<br>
            PRECSSでは特に規則を設けませんが、単語を省略する場合は<a href="https://google.github.io/styleguide/htmlcssguide.html#ID_and_Class_Name_Style" target="_blank" rel="noopener">Google HTML/CSS Style Guide</a>に基づくことを推奨します。<br>
            また2語以上で1つのまとまりを表す語群は、それぞれの頭文字の大文字のみで表現することも推奨します。ただし、ある程度一般的であったり、連続するパターンがあることが望ましいでしょう。<br>
            その他、一般的に使われる語を参考として併せて提示します。
          </p>
          <dl>
            <dt>一般的な例</dt>
            <dd>・mainVisual→MV</dd>
          </dl>
          <dl>
            <dt>連続するパターンの例</dt>
            <dd>・northEurope→NE</dd>
            <dd>・northAmerica→NA</dd>
            <dd>・southAmerica→SA</dd>
          </dl>
          <dl>
            <dt>よく使われる省略語</dt>
            <dd>・category(ies) → cat(s)</dd>
            <dd>・column → col</dd>
            <dd>・content(s) → cont(s)</dd>
            <dd>・level → lv</dd>
            <dd>・version → v</dd>
            <dd>・section → sect</dd>
            <dd>・description → desc</dd>
            <dd>・button → btn</dd>
            <dd>・clearfix → cf</dd>
            <dd>・image → img</dd>
            <dd>・number → num</dd>
            <dd>・title → ttl</dd>
            <dd>・text → txt</dd>
            <dd>
              ・left → l<br>
              ただし後述のlargeの省略系であるlと被るため、下記いずれかの方針を推奨します。
              <ul class="bl_nestedList hp_mb0">
                <li>leftまたはrightであるというコンテキストが明確な場合にのみ、省略系を使用する</li>
                <li>後述のサイズを1文字ではなく2文字で表す</li>
                <li>leftとrightについては省略しない</li>
              </ul>
            </dd>
            <dd>・right → r</dd>
            <dd>・small → sm または s</dd>
            <dd>・medium → md または m</dd>
            <dd>・large → lg または l</dd>
            <dd>・reverse → rev</dd>
          </dl>

          <h3 id="nameRule_series" class="el_lv3Heading">シリーズを形成する場合</h3>
          <p>
            類似しているものはなるべく意味のある、または目的に即した命名を推奨しますが、ときに名前の付け分けが難しい場合もあるでしょう。そのような際は連番を付けて管理することも許容します。ただしその場合、1つ目のものには連番を付けません。<br>
            これは、仮に「ひとつ目にすべて連番を付ける」としてしまうと、後からシリーズを形成するようになった際、ひとつ目のものに連番を付け直す手間が発生してしまうからです。
          </p>
          
          
  <div class="bl_codeBlock">
    <em class="bl_codeBlock_ttl">× 1つ目に連番を付けている</em>
    <pre class="brush:html; class-name:'light'; highlight:[1]">
      
            &lt;div class=&#34;bl_halfMedia1&#34;&gt;...&lt;/div&gt;
            &lt;div class=&#34;bl_halfMedia2&#34;&gt;...&lt;/div&gt;
            &lt;div class=&#34;bl_halfMedia3&#34;&gt;...&lt;/div&gt;
    </pre>
  </div>
  <!-- /.bl_codeBlock -->

          
          
  <div class="bl_codeBlock">
    <em class="bl_codeBlock_ttl">○ 1つ目に連番を付けていない</em>
    <pre class="brush:html; class-name:''; highlight:[1]">
      
            &lt;div class=&#34;bl_halfMedia&#34;&gt;...&lt;/div&gt;
            &lt;div class=&#34;bl_halfMedia2&#34;&gt;...&lt;/div&gt;
            &lt;div class=&#34;bl_halfMedia3&#34;&gt;...&lt;/div&gt;
    </pre>
  </div>
  <!-- /.bl_codeBlock -->

        </section>
        <!-- /.bl_sect bl_wysiwyg -->
      </div>
      <!-- /.ly_body -->

      <div class="bl_sectBlockCalm">
        <p class="bl_sectBlockCalm_txt">Documentation</p>
      </div>
          <!-- /.bl_sectBlockCalm -->

      <div class="ly_cont">
        <section class="bl_sect bl_wysiwyg">
          <h2 class="el_lv2Heading">基本設計</h2>
          <p>
            PRECSSは下記の6つのグループから構成されています。<br>
            <small>※ソースコードは最低限解説に必要な記述のみを記載しています。</small>
          </p>
          <ol>
            <li><a href="#base">ベース</a></li>
            <li><a href="#layout">レイアウト</a></li>
            <li>
              <a href="#module">モジュール</a>
              <ol class="bl_simpleList hp_mb0">
                <li><a href="#block">ブロックモジュール</a></li>
                <li><a href="#element">エレメントモジュール</a></li>
                <li><a href="#modifier">（モディファイア）</a></li>
              </ol>
            </li>
            <li><a href="#helper">ヘルパー</a></li>
            <li><a href="#unique">ユニーク</a></li>
            <li><a href="#program">プログラム</a></li>
            <li><a href="#original">(オリジナル)</a></li>
          </ol>

          <h3 id="base" class="el_lv3Heading">1.ベース</h3>
          <p>
            <b class="el_emphasis">接頭辞：なし</b>
          </p>
          <p>
            ベースグループはSMACSSと同じように扱います。reset.cssやnormalize.cssによる素地作りの他、サイト全体にまつわるスタイルを要素セレクタに直接指定します。<br>
            またPRECSSでは、特定のスコープ内における限定的なベーススタイルの適用も許容します。<br>
            例えば「ヘッダー内のリンクは全て白色だが、フッター内は青色に統一したい」という場合に、限定的なベーススタイルを使用します。ただし詳細度を高める行為であるため、十分注意して使用してください。
          </p>
          
          
  <div class="bl_codeBlock">
    <em class="bl_codeBlock_ttl">○ ベーススタイルの例</em>
    <pre class="brush:css; class-name:''; highlight:[]">
      
            body {
              font-family: serif;
            }
            a {
              color: #1565c0;
              text-decoration: none;
            }
            img {
              max-width: 100%;
              vertical-align: top;
            }

            // 限定的なベーススタイルの例
            .ly_header a {
              color: #fff;
            }
            .ly_footer a {
              color: blue;
            }
    </pre>
  </div>
  <!-- /.bl_codeBlock -->


          <h3 id="layout" class="el_lv3Heading">2.レイアウト</h3>
          <p>
            <b>接頭辞：ly_（layoutの略）</b>
          </p>
          <p>
            ヘッダー、ボディエリア、メインエリア、サイドエリア、フッター等の大きなレイアウトを形成する要素に使用します。<br>
            原則としてこのグループには、レイアウトに関わるスタイリング（gridやflex、width、margin、padding、floatなど）しか行いません。あくまでコンテンツが入る「枠」を定義するだけで、コンテンツは後述するモジュールグループで作成します。<br>
            ただし「ヘッダーの背景色は黒」など「枠」と「あしらい」の粒度が一致している場合は、必要に応じてレイアウト以外のスタイリングを行うことも許容します。
          </p>
          <iframe title="レイアウトグループのサンプル" loading="lazy" class="el_iframe js_iframe" src="/sample/layout.html" onload="resizeIframe(this)"></iframe>
          
          
  <div class="bl_codeBlock">
    <em class="bl_codeBlock_ttl">HTML</em>
    <pre class="brush:html; class-name:''; highlight:[]">
      
            &lt;header class=&#34;ly_header&#34;&gt;
              &lt;div class=&#34;ly_header_inner&#34;&gt;
                ...
              &lt;/div&gt;
              &lt;!-- /.ly_header_inner --&gt;
            &lt;/header&gt;
            &lt;div class=&#34;ly_cont ly_cont__col&#34;&gt; &lt;!-- モディファイアについては後述します --&gt;
              &lt;main class=&#34;ly_cont_main&#34;&gt;
                ...
              &lt;/main&gt;
              &lt;aside class=&#34;ly_cont_side&#34;&gt;
                ...
              &lt;/aside&gt;
            &lt;/div&gt;
            &lt;!-- /.ly_cont ly_cont__col --&gt;
            &lt;footer class=&#34;ly_footer&#34;&gt;
              &lt;div class=&#34;ly_footer_inner&#34;&gt;
                ...
              &lt;/div&gt;
              &lt;!-- /.ly_footer_inner --&gt;
            &lt;/footer&gt;
    </pre>
  </div>
  <!-- /.bl_codeBlock -->

          
          
  <div class="bl_codeBlock">
    <em class="bl_codeBlock_ttl">CSS</em>
    <pre class="brush:css; class-name:''; highlight:[]">
      
            .ly_header {
              padding-top: 10px;
              padding-bottom: 10px;
              background-color: #f4d9d9;
            }
            .ly_header_inner {
              max-width: 1230px;
              padding-right: 15px;
              padding-left: 15px;
              margin-right: auto;
              margin-left: auto;
            }

            .ly_cont {
              max-width: 1230px;
              padding: 60px 15px;
              margin-right: auto;
              margin-left: auto;
            }
            .ly_cont.ly_cont__col { // モディファイアについては後述します
              display: flex;
            }
            .ly_cont_main {
              flex: 1;
              margin-right: 3.25203%;
            }
            .ly_cont_side {
              flex: 0 0 260px;
            }

            .ly_footer {
              padding-top: 20px;
              padding-bottom: 20px;
              background-color: #dbd9e5;
            }
            .ly_footer_inner {
              max-width: 1230px;
              padding-right: 15px;
              padding-left: 15px;
              margin-right: auto;
              margin-left: auto;
            }
    </pre>
  </div>
  <!-- /.bl_codeBlock -->


          <h3 id="module" class="el_lv3Heading">3.モジュール</h3>
          <p>
            PRECSSでは再利用性の高いコードをモジュールとして管理します。モジュールは大きさよって
          </p>
          <ul>
            <li>ブロックモジュール</li>
            <li>エレメントモジュール</li>
          </ul>
          <p>
            の2つの粒度に分けて定義しています。
          </p>

          <h4 id="block" class="el_lv4Heading">3-1.ブロックモジュール</h4>
          <p>
            <b>接頭辞：bl_（blockの略）</b>
          </p>
          <p>
            ブロックモジュールは、そのモジュール特有の幾つかの子要素を持ち、また後述するエレメントモジュールや他のブロックモジュールを含むこともできます。<em>一つの塊として持ち運び可能な要素群</em>を形成し、BEMで例えるならば「複数のElementを持つBlock」と言い換えることができます。<br>
            それら複数の子要素やエレメントモジュールを1つの塊としてまとめ、サイト内のどこでも使用できるようにすることがブロックモジュールの基本的な考え方です。webサイトの中核を担うもので、多くのモジュールはこのブロックモジュールに該当します。<br>
            以下はブロックモジュールの例です。
          </p>
          <iframe title="ブロックモジュールのサンプル" loading="lazy" class="el_iframe js_iframe" src="/sample/blockModule.html" onload="resizeIframe(this)"></iframe>
          
          
  <div class="bl_codeBlock">
    <em class="bl_codeBlock_ttl">HTML</em>
    <pre class="brush:html; class-name:''; highlight:[]">
      
            &lt;div class=&#34;bl_jumbotron&#34; style=&#34;background-image: url(&#39;https://picsum.photos/1200/600&#39;);&#34;&gt;
              &lt;div class=&#34;bl_jumbotron_inner&#34;&gt;
                &lt;p class=&#34;bl_jumbotron_ttl&#34;&gt;TITLE HERE&lt;/p&gt;
              &lt;/div&gt;
              &lt;!-- /.bl_jumbotron_inner --&gt;
            &lt;/div&gt;
            &lt;!-- /.bl_jumbotron --&gt;

            &lt;div class=&#34;bl_media&#34;&gt;
              &lt;figure class=&#34;bl_media_imgWrapper&#34;&gt;
                &lt;img alt=&#34;Dummy Image&#34; src=&#34;https://picsum.photos/640/426&#34;&gt;
              &lt;/figure&gt;
              &lt;div class=&#34;bl_media_body&#34;&gt;
                &lt;h3 class=&#34;bl_media_ttl&#34;&gt;TITLE HERE&lt;/h3&gt;
                &lt;p class=&#34;bl_media_txt&#34;&gt;...&lt;/p&gt;
              &lt;/div&gt;
              &lt;!-- /.bl_media_body --&gt;
            &lt;/div&gt;
            &lt;!-- /.bl_media --&gt;
    </pre>
  </div>
  <!-- /.bl_codeBlock -->

          
          
  <div class="bl_codeBlock">
    <em class="bl_codeBlock_ttl">CSS</em>
    <pre class="brush:css; class-name:''; highlight:[]">
      
            .bl_jumbotron {
              width: 100%;
              height: 300px;
              background-position: center center;
              background-size: cover;
            }
            .bl_jumbotron_inner { ... }
            .bl_jumbotron_ttl { ... }

            .bl_media {
              display: flex;
              align-items: center;
            }
            .bl_media_imgWrapper { ... }
            .bl_media_imgWrapper &gt; img { ... }
            .bl_media_body { ... }
            .bl_media_ttl { ... }
            .bl_media_txt { ... }
    </pre>
  </div>
  <!-- /.bl_codeBlock -->


          <p>
            子要素のクラス名は、モジュールのルート要素の名前のみを継承するのが基本です。しかしBasics内の<a href="#nameRule">命名規則</a>セクションでも触れましたが、
          </p>
          <ul>
            <li>親子関係を意図をもって明確に定義したい</li>
            <li>モジュールが大きいため、子要素の名前の重複を避けたい</li>
          </ul>
          <p>
            のいずれかに該当する場合は、 ネストされた子要素のクラス名に直近の親要素の名前を含めることも許容します。<br>
            次のコードは4・8・9行目でそれぞれ直近の親要素のクラス名を引き継ぎ、構造（依存）を明確にするとともにクラス名の重複を回避しています。
          </p>

          <iframe title="ネストされた子要素のクラス名に直近の子要素の名前を含めた例" loading="lazy" class="el_iframe js_iframe" src="/sample/blockModule2.html" onload="resizeIframe(this)"></iframe>

          
          
  <div class="bl_codeBlock">
    <em class="bl_codeBlock_ttl">HTML</em>
    <pre class="brush:html; class-name:''; highlight:[4,8,9]">
      
            &lt;dl class=&#34;bl_faq&#34;&gt;
              &lt;dt class=&#34;bl_faq_q&#34;&gt;
                &lt;span class=&#34;bl_faq_icon&#34;&gt;Q&lt;/span&gt;
                &lt;span class=&#34;bl_faq_q_txt&#34;&gt;Question Here&lt;/span&gt;
              &lt;/dt&gt;
              &lt;dd class=&#34;bl_faq_a&#34;&gt;
                &lt;span class=&#34;bl_faq_icon&#34;&gt;A&lt;/span&gt;
                &lt;div class=&#34;bl_faq_a_body&#34;&gt;
                  &lt;p class=&#34;bl_faq_a_txt&#34;&gt;Answer Here&lt;/p&gt;
                &lt;/div&gt;
                &lt;!-- /.bl_faq_a_body --&gt;
              &lt;/dd&gt;
            &lt;/dl&gt;
    </pre>
  </div>
  <!-- /.bl_codeBlock -->

          
          
  <div class="bl_codeBlock">
    <em class="bl_codeBlock_ttl">CSS</em>
    <pre class="brush:css; class-name:''; highlight:[5,10,11]">
      
            .bl_faq { ... }
            .bl_faq_q,
            .bl_faq_a { ... }
            .bl_faq_q { ... }
            .bl_faq_q_txt { ... }
            .bl_faq_a { ... }
            .bl_faq_icon { ... }
            .bl_faq_q .bl_faq_icon { ... }
            .bl_faq_a .bl_faq_icon { ... }
            .bl_faq_a_body { ... }
            .bl_faq_a_txt { ... }
    </pre>
  </div>
  <!-- /.bl_codeBlock -->


          <p>
            またPRECSSではSMACSSと同様に、子要素のタグにスタイルを直接指定することを許容します。ただしその際はなるべく子結合子で指定をすること、<code>div</code>や<code>span</code>等のセマンティックでない要素は独自のクラスを付加することを推奨します。<br>
            また、あまり階層が深くなり過ぎるとコードの見通しや詳細度の管理に影響が出る恐れがあるため、ネストは3階層程度までを目処とし、それ以上になりそうな場合は適宜クラスを付加することを推奨します。
          </p>
          
          
  <div class="bl_codeBlock">
    <em class="bl_codeBlock_ttl">HTML</em>
    <pre class="brush:html; class-name:''; highlight:[]">
      
              &lt;ul class=&#34;bl_bulletList&#34;&gt;
                &lt;li&gt;list 1&lt;/li&gt;
                &lt;li&gt;list 2&lt;/li&gt;
              &lt;/ul&gt;
    </pre>
  </div>
  <!-- /.bl_codeBlock -->

          
          
  <div class="bl_codeBlock">
    <em class="bl_codeBlock_ttl">CSS</em>
    <pre class="brush:css; class-name:''; highlight:[]">
      
              .bl_bulletList {
                padding-left: 1em;
                margin-bottom: 20px;
              }
              .bl_bulletList &gt; li {
                list-style-type: circle;
              }
    </pre>
  </div>
  <!-- /.bl_codeBlock -->


          <h5 id="block_applicable" class="el_lv5Heading">ブロックモジュールに適用可能なスタイル</h5>
          <p>
            注意点として、<em>ブロックモジュールにはレイアウトに関わらないスタイルのみの適用を基本とします</em>。<br>
            レイアウトに関わるスタイル、即ち
            <code>width（100%は例外）</code>
            や
            <code>position: absolute / fixed / sticky</code>、
            <code>top / right / bottom / left</code>
            、
            <code>margin</code>
            、
            <code>float</code>
            等は、コンテキストまたはラッパーモジュールからスタイルを適用します。コンテキストの例については<a href="#nestedModule">Advance Case</a>を、ラッパーモジュールの例についてはこの後の「複数カラムの例」のコードを参考にしてください。<br>
            <em>即ちブロックモジュールの幅は、なるべく初期値のまま（多くはブロックレベルであるため、横いっぱいに広がる）あることが望ましく</em>、このことにより高い拡張性と移植性が実現されます。<br>
            ただし例外として、デザイン上でモジュールの上下間の余白に統一されたルールがある場合は、
            <code>margin-top / bottom</code>
            の適用を許容します。
          </p>
          <p>
            これらについては、カラムを形成するブロックモジュールを例に考えると理解しやすいでしょう。
          </p>

          <h6 class="el_lv6Heading">1カラムの例</h6>
          <p>
            この状態ブロックモジュールの基本状態であり、もちろん単体で使用できるほか、レイアウトに関する指定をしないことで何処へでも移植することが可能です。
          </p>
          <iframe title="ブロックモジュールの基本状態の例" loading="lazy" class="el_iframe js_iframe" src="/sample/blockModule3.html" onload="resizeIframe(this)"></iframe>
          
          
  <div class="bl_codeBlock">
    <em class="bl_codeBlock_ttl">HTML</em>
    <pre class="brush:html; class-name:''; highlight:[]">
      
            &lt;div class=&#34;bl_card&#34;&gt;
              &lt;figure class=&#34;bl_card_imgWrapper&#34;&gt;
                &lt;img alt=&#34;Dummy Image&#34; src=&#34;//placehold.jp/E13626/fff/1280x718.png?text=Card 1&#34;&gt;
              &lt;/figure&gt;
              &lt;div class=&#34;bl_card_body&#34;&gt;
                &lt;h3 class=&#34;bl_card_ttl&#34;&gt;TITLE HERE&lt;/h3&gt;
                &lt;p class=&#34;bl_card_txt&#34;&gt; ... &lt;/p&gt;
              &lt;/div&gt;
              &lt;!-- /.bl_card_body --&gt;
            &lt;/div&gt;
            &lt;!-- /.bl_card --&gt;
    </pre>
  </div>
  <!-- /.bl_codeBlock -->

          
          
  <div class="bl_codeBlock">
    <em class="bl_codeBlock_ttl">CSS</em>
    <pre class="brush:css; class-name:''; highlight:[]">
      
            .bl_card {
              width: 100%;
              background-color: #fff;
              box-shadow: 0 3px 6px rgba(0, 0, 0, 0.16);
            }
            .bl_card_imgWrapper { ... }
            .bl_card_imgWrapper &gt; img { ... }
            .bl_card_body { ... }
            .bl_card_ttl { ... }
            .bl_card_txt { ... }
    </pre>
  </div>
  <!-- /.bl_codeBlock -->


          <h6 class="el_lv6Heading">複数カラムの例</h6>
          <p>
            <code>bl_cardUnit</code>
            というラッパーモジュールを作成してでラップすることにより、他の箇所で使われている既存のブロックモジュールに影響を与えることなく、またCSSの修正の必要もなく再利用することができます。<br>
            さらに
            <code>bl_cardUnit</code>
            自体が高次のブロックモジュールとなったため、<em>今後は
              <code>bl_cardUnit</code>
                                                         を他に移植することも可能</em>となります。<br>
            またwidthをカラム数に応じたモディファイアから制御することで、高い拡張性を実現します。CSSにおいて、元の <code>.bl_card</code>モジュールのスタイリングは一切調整していないことに着目してください。
          </p>
          <iframe title="ブロックモジュールがカラムを形成する例" loading="lazy" class="el_iframe js_iframe" src="/sample/blockModule4.html" onload="resizeIframe(this)"></iframe>
          
          
  <div class="bl_codeBlock">
    <em class="bl_codeBlock_ttl">HTML</em>
    <pre class="brush:html; class-name:''; highlight:[1,7]">
      
            &lt;ul class=&#34;bl_cardUnit bl_cardUnit__col3&#34;&gt;
              &lt;li class=&#34;bl_card&#34;&gt; ... &lt;/li&gt;
              &lt;li class=&#34;bl_card&#34;&gt; ... &lt;/li&gt;
              &lt;li class=&#34;bl_card&#34;&gt; ... &lt;/li&gt;
            &lt;/ul&gt;

            &lt;ul class=&#34;bl_cardUnit bl_cardUnit__col4&#34;&gt;
              &lt;li class=&#34;bl_card&#34;&gt; ... &lt;/li&gt;
              &lt;li class=&#34;bl_card&#34;&gt; ... &lt;/li&gt;
              &lt;li class=&#34;bl_card&#34;&gt; ... &lt;/li&gt;
              &lt;li class=&#34;bl_card&#34;&gt; ... &lt;/li&gt;
            &lt;/ul&gt;
    </pre>
  </div>
  <!-- /.bl_codeBlock -->

          
          
  <div class="bl_codeBlock">
    <em class="bl_codeBlock_ttl">CSS</em>
    <pre class="brush:css; class-name:''; highlight:[6,19]">
      
            .bl_cardUnit {
              display: flex;
              flex-wrap: wrap;
            }

            // 3カラム
            .bl_cardUnit.bl_cardUnit__col3 {
              margin-bottom: 10px;
            }
            .bl_cardUnit__col3 &gt; .bl_card {
              width: 31.707%;
              margin-right: 2.43902%;
              margin-bottom: 30px;
            }
            .bl_cardUnit__col3 &gt; .bl_card:nth-of-type(3n) {
              margin-right: 0;
            }

            // 4カラム
            .bl_cardUnit.bl_cardUnit__col4 {
              margin-bottom: -20px;
            }
            .bl_cardUnit__col4 &gt; .bl_card {
              width: 23.78%;
              margin-right: 1.62602%;
              margin-bottom: 20px;
            }
            .bl_cardUnit__col4 &gt; .bl_card:nth-of-type(4n) {
              margin-right: 0;
            }

            @media screen and (max-width: 768px) {
              .bl_cardUnit.bl_cardUnit__col3 {
                margin-bottom: -20px;
              }
              .bl_cardUnit.bl_cardUnit__col4 {
                margin-bottom: -15px;
              }
              .bl_cardUnit &gt; .bl_card {
                width: 100%;
                margin-right: 0;
                margin-bottom: 20px;
              }
            }
    </pre>
  </div>
  <!-- /.bl_codeBlock -->

          <p>
            極端な例を示すと、これらをメインエリア・サイドエリアそれぞれに移植するとこのような形になります。きちんと設計しておけば、ここまで極端なことをしても期待通りにモジュールが動作します。
          </p>
          <iframe title="ブロックモジュールを極端に使用した例" loading="lazy" class="el_iframe js_iframe" src="/sample/blockModule5.html" onload="resizeIframe(this)"></iframe>

          <p>
            以上のようにブロックモジュールというのは非常に柔軟で、パワフルにサイト内を駆け回ることができます。
          </p>
          <p>
            今回の例では
            <code>.bl_cardUnit</code>
            という専用のラッパーモジュールを作成しましたが、「<em>ブロックモジュールのwidthは初期値のまま（または100%）にしておく</em>」ということを遵守していれば、他のCSSフレームワークが提供するグリッドシステムと連携することも可能です。<br>
            ただし、その高い移植性を維持するためには「レイアウトに関するスタイルは1つ上のレイヤー（ラッパーモジュールまたはコンテキスト）から制御する」という少し特殊なテクニックが必要で、慣れないうちは苦労するでしょう。<br>
            コンテキストを利用した例、さらに複雑なブロックモジュールの移植については、下部に<a href="#nestedModule">Advance Case</a>としてまとめたので、そちらをご参照ください。
          </p>
          <p>
            また下記に、ブロックモジュールを命名する際に役立つ粒度の指針を提供します。<br>PRECSSにおいてブロックモジュールは非常に重要な役割を担うため、これらの単語を分かりづらい形に省略することは推奨しません。<br>
            必ずしもこれらの名前を含まなければならない訳ではありませんが（私自身、基本単位である「block」という単語は含まないことが多いです）、これらを参考にすることは、あなたがブロックモジュールを自在に操ることを強力に手助けしてくれると思います。<br>
            現実として、Unit以上の大きさを使用することはあまり無いでしょう。
          </p>

          <h5 id="block_nameSize" class="el_lv5Heading">ブロックモジュールにおける概念・命名の粒度</h5>
          <ul>
            <li>Block - ブロックモジュールの基本単位。そのモジュール特有の複数の子要素や、エレメントモジュールを含む（例：bl_card）</li>
            <li>Unit - Blockの集まり（例：bl_cardUnit）</li>
            <li>
              <del>Box - Unitの集まり</del>
              「Box」という単語は純粋にモジュール名に含みたい場合があるので、非推奨としました。
            </li>
            <li>Container - Unitの集まり</li>
          </ul>

        <h4 id="element" class="el_lv4Heading">3-2.エレメントモジュール</h4>
        <p>
          <b>接頭辞：el_（elementの略）</b>
        </p>
        <p>
          ボタンやラベル、見出し等の最小単位のモジュールで、どこにでも埋め込むことが可能なモジュールです。<br>
          命名は<em>極力汎用的なもの</em>を推奨します。これはどのようなコンテンツが入っても、名前と内容が乖離しないための措置です。<br>
          「極力汎用的な命名を」というのはBEMとは真逆の方向を向いている思想ですが、現実として、例えば全ての色に意味を持たせた命名は困難です。
          <small>※もちろんプロジェクトのデザインシステムにおいて、スタイルと命名がセマンティックに一致する場合は、その限りではありません（色がきちんとテーマカラーとして定義されていたり、商品やブランドがテーマカラーを持つ場合など）。</small>
        </p>
        <p>
          類似するスタイルのエレメントモジュールが複数存在する場合は、OOCSSにおけるストラクチャとスキンの考え方を使用します。<br>
          個別のスキンは後述するモディファイアで実装しますが、ベースクラスに標準状態として予めスキンを適用することでモディファイアを減らすことも推奨します（次のコードにおける.el_label、.el_btn）。
        </p>

        <iframe title="エレメントモジュールの例" loading="lazy" class="el_iframe js_iframe" src="/sample/elementModule.html" onload="resizeIframe(this)"></iframe>
        
        
  <div class="bl_codeBlock">
    <em class="bl_codeBlock_ttl">× 名前が汎用的でない</em>
    <pre class="brush:html; class-name:'light'; highlight:[10,14,25,26]">
      
          &lt;div class=&#34;bl_media hp_mb30&#34;&gt;
            &lt;figure class=&#34;bl_media_imgWrapper&#34;&gt;
              ...
            &lt;/figure&gt;
            &lt;div class=&#34;bl_media_body&#34;&gt;
              &lt;h3 class=&#34;bl_media_ttl&#34;&gt; ... &lt;/h3&gt;
              &lt;ul class=&#34;bl_media_labels&#34;&gt;
                &lt;li&gt;
                  &lt;!-- 名前が汎用的でないため推奨しない --&gt;
                  &lt;span class=&#34;el_label el_label__news&#34;&gt;News&lt;/span&gt;
                &lt;/li&gt;
                &lt;li&gt;
                  &lt;!-- 名前が汎用的でないため推奨しない --&gt;
                  &lt;span class=&#34;el_label el_label__blog&#34;&gt;Blog&lt;/span&gt;
                &lt;/li&gt;
              &lt;/ul&gt;
              &lt;p class=&#34;bl_media_txt&#34;&gt; ... &lt;/p&gt;
            &lt;/div&gt;
            &lt;!-- /.bl_media_body --&gt;
          &lt;/div&gt;
          &lt;!-- /.bl_media --&gt;

          &lt;p class=&#34;hp_tac&#34;&gt;
          &lt;!-- 名前が汎用的でないため推奨しない --&gt;
            &lt;button class=&#34;el_btn el_btn__cancel&#34; type=&#34;button&#34;&gt;Cancel&lt;/button&gt;
            &lt;button class=&#34;el_btn el_btn__submit&#34; type=&#34;button&#34;&gt;Submit&lt;/button&gt;
          &lt;/p&gt;
    </pre>
  </div>
  <!-- /.bl_codeBlock -->

        
        
  <div class="bl_codeBlock">
    <em class="bl_codeBlock_ttl">○ 名前が汎用的であり、かつベースクラスにスキンを標準適用している</em>
    <pre class="brush:html; class-name:''; highlight:[9,12,22,23]">
      
          &lt;div class=&#34;bl_media hp_mb30&#34;&gt;
            &lt;figure class=&#34;bl_media_imgWrapper&#34;&gt;
              ...
            &lt;/figure&gt;
            &lt;div class=&#34;bl_media_body&#34;&gt;
              &lt;h3 class=&#34;bl_media_ttl&#34;&gt; ... &lt;/h3&gt;
              &lt;ul class=&#34;bl_media_labels&#34;&gt;
                &lt;li&gt;
                  &lt;span class=&#34;el_label&#34;&gt;News&lt;/span&gt;
                &lt;/li&gt;
                &lt;li&gt;
                  &lt;span class=&#34;el_label el_label__blue&#34;&gt;Blog&lt;/span&gt;
                &lt;/li&gt;
              &lt;/ul&gt;
              &lt;p class=&#34;bl_media_txt&#34;&gt; ... &lt;/p&gt;
            &lt;/div&gt;
            &lt;!-- /.bl_media_body --&gt;
          &lt;/div&gt;
          &lt;!-- /.bl_media --&gt;

          &lt;p class=&#34;hp_tac&#34;&gt;
            &lt;button class=&#34;el_btn el_btn__blue&#34; type=&#34;button&#34;&gt;Cancel&lt;/button&gt;
            &lt;button class=&#34;el_btn&#34; type=&#34;button&#34;&gt;Submit&lt;/button&gt;
          &lt;/p&gt;
    </pre>
  </div>
  <!-- /.bl_codeBlock -->

        
        
  <div class="bl_codeBlock">
    <em class="bl_codeBlock_ttl">○ CSSの実装例</em>
    <pre class="brush:css; class-name:''; highlight:[]">
      
          .el_label {
            display: inline-block;
            padding: .2em .5em;
            background-color: #de5b5b;
            color: #fff;
            font-size: .75rem;
          }
          .el_label.el_label__blue {
            background-color: #308EDE;
          }

          .el_btn {
            display: inline-block;
            width: 200px;
            max-width: 100%;
            padding: 10px 5px;
            border-radius: 5px;
            box-sizing: border-box;
            background-color: #E18700;
            box-shadow: 0 3px 0 #B85F29;
            color: #fff;
            text-align: center;
            text-decoration: none;
            transition: .25s;
          }
          .el_btn.el_btn__blue {
            background-color: #308EDE;
            box-shadow: 0 3px 0 #2572B1;
          }

          .hp_tac {
            text-align: center !important;
          }
    </pre>
  </div>
  <!-- /.bl_codeBlock -->

        <p>例えばもし、この青がサイトにおけるアクセントカラーとデザインシステムで定義されている場合は、モディファイア名を「<code>.el_btn__accent / .el_btn__accentColor</code>」とすることも推奨します。そうすると、万が一アクセントカラーが青から変更になっても、モディファイア名を変える必要はありません。</p>

      <h5 id="element_layout" class="el_lv5Heading">レイアウトについて</h5>
      <p>
        移植性の維持のため、ブロックモジュールと同じく<em>エレメントモジュール自体にレイアウトのためのスタイルを当てることは推奨しません</em>。<br>
        コンテキストから制御するか、もしくは上記の
        <code>.hp_tac</code>
        のように何らかの親要素を使用するのが理想です（
        <code>.hp_</code>
        については次のヘルパーセクションで解説します）。<br>
        ただし、ブロックモジュールに比べエレメントモジュールはサイト全体でバリエーションに限りがあることが多いため、widthの直接指定、及びモディファイアでサイズのパターンを作成することは十分許容します。例えば、ボタンのサイズは多くのデザインにおいてパターンがあるでしょう。
      </p>
      <p>
        ただし、例えば
      </p>
      <ul>
        <li>レスポンシブ・ウェブデザインを採用し</li>
        <li>スマートフォンを想定するビューでは、ボタンを横幅100%にする</li>
      </ul>
      <p>
        となった際に、モディファイアの名前を
        <code>__w250</code>
        （width: 250pxの意）と数値を固定すると、
        <code>__w250</code>
        と付いているのにSPビューでの実際の表示は横幅100％という事態が発生します。
        このように名前と実際の大きさに矛盾が発生すると<em>破綻への第一歩</em>となることは留意しておいてください。<br>
        状況にもよりますが、解決策としては
      </p>
      <ul>
        <li>サイズを指定する場合は、モディファイア名は
          <code>__sm</code>
            ・
          <code>__md</code>
            ・
          <code>__lg</code>
            などとする
        </li>
        <li>サイズを指定せずコンテンツに応じて可変にする場合は、
          <code>display: inline-block;</code>
            としておく
        </li>
      </ul>
      <p>
        などすると、応用が効くでしょう。
      </p>
      <p>
        あまりエレメントモジュールのモディファイアパターンにハマらない場合は、もちろん移植先のモジュールのElementとしての指定か、子（孫）セレクタを使用してスタイリングすることも可能です。<br>
        次のコードはコンテキストから制御した例と、モディファイアで制御した例です。
      </p>
      <iframe title="エレメントモジュールの調整する場合の2パターンの例" loading="lazy" class="el_iframe js_iframe" src="/sample/elementModule2.html" onload="resizeIframe(this)"></iframe>
      
      
  <div class="bl_codeBlock">
    <em class="bl_codeBlock_ttl">HTML</em>
    <pre class="brush:html; class-name:''; highlight:[]">
      
        &lt;header class=&#34;ly_header&#34;&gt;
          &lt;div class=&#34;ly_header_inner&#34;&gt;
            &lt;!-- コンテキストから制御した例 --&gt;
            &lt;a class=&#34;el_btn&#34; href=&#34;#&#34;&gt;.el_btn&lt;/a&gt;
          &lt;/div&gt;
          &lt;!-- /.ly_header_inner --&gt;
        &lt;/header&gt;

        &lt;p class=&#34;hp_tac&#34;&gt;
          &lt;!-- モディファイアで制御した例 --&gt;
          &lt;a class=&#34;el_btn el_btn__lg&#34; href=&#34;#&#34;&gt;.el_btn.el_btn__l&lt;/a&gt;
        &lt;/p&gt;
    </pre>
  </div>
  <!-- /.bl_codeBlock -->


      
      
  <div class="bl_codeBlock">
    <em class="bl_codeBlock_ttl">CSS</em>
    <pre class="brush:css; class-name:''; highlight:[]">
      
        // コンテキストから制御した例
        .ly_header_inner &gt; .el_btn {
          display: block;
          margin-left: auto;
          width: 150px;
        }

        // モディファイアで制御した例
        .el_btn.el_btn__l {
          width: 400px;
          padding-top: 1em;
          padding-bottom: 1em;
        }
        @media screen and (max-width: 768px) {
          .el_btn.el_btn__l {
            width: 100%;
          }
        }
    </pre>
  </div>
  <!-- /.bl_codeBlock -->


        <h4 id="modifier" class="el_lv4Heading">3-3.モディファイア</h4>
        <p>
          <b>命名規則：基となるクラス名__モディファイア名</b><br>
          既に何度か言及していますが、
        </p>
        <ul>
          <li>あしらいが変わる</li>
          <li>大きさが変わる</li>
          <li>一定の規則に従って振る舞いが変わる（カラム等）</li>
        </ul>
        <p>
          などの場合はモディファイアによる上書きをPRECSSでは推奨し、アンダースコア2つの後にモディファイア名を付与します。<br>
          「何をするモディファイアなのか」を明確にするために、モディファイア名は「
          <code>__backgroundColorOrange</code>
          」のように「
          <code>__keyValue</code>
          」の形を基本としますが、おおよそ想像がつくものであればkeyの省略が可能です。<br>
          また名前が長くなるのを避けたい場合は、Emmetのショートハンドに準じて「
          <code>__backgroundColorOrange</code>
          」を「
          <code>__bgcOrange</code>
          」のように省略することも可能です。
        </p>
        <p>
          多くはモジュールグループにおいて使用されますが、状況によってはレイアウトグループなど、他のグループに使用することもできます。<br>
          注意点としてモディファイアでスタイルを上書きする際は、<em>基本的に複数クラスを使用して、詳細度を高めることを推奨しています。</em><br>
          「スタイルを上書きする」ということは意図的なアクションであり、であればCSSの読み込み順でスタイルに変化が出てしまうのは好ましくありません。
        </p>
        <p>
          これもBEMとは異なる思想ですが、「CSSが自分の手を離れても、CSSのルールセットの順番が変わることは絶対ない」と言い切ることは私にはできません。<br>
          そのためweb開発者の都合を優先するのではなく、あくまで「スタイルを上書きする」という目的に立ち返り、想定外の事態が発生してもなるべくサイトが壊れないことを優先し、このようなルールとしています。
        </p>
        <p>
          また「状態（active, disabledなど）」を変更する際にももちろんモディファイアを使用することができますが、基本的には後述するプログラムグループで変更を制御することをPRECSSでは推奨しています。
        </p>

        <h5 id="modifier_element" class="el_lv5Heading">エレメントモジュールの例</h5>
        
        
  <div class="bl_codeBlock">
    <em class="bl_codeBlock_ttl">× 詳細度を高めていない</em>
    <pre class="brush:css; class-name:'light'; highlight:[]">
      
            .el_btn__orange {
              background-color: orange;
            }
            .el_btn {
              background-color: white;
            }
            //適用されるカラー：white
            //何らかの都合でスタイルの読み込み順が変わったとき、モディファイアが機能しなくなってしまう
    </pre>
  </div>
  <!-- /.bl_codeBlock -->

        
        
  <div class="bl_codeBlock">
    <em class="bl_codeBlock_ttl">○ 詳細度を高めている</em>
    <pre class="brush:css; class-name:''; highlight:[]">
      
            .el_btn {
              background-color: white;
            }
            .el_btn.el_btn__orange {
              background-color: orange;
            }
    </pre>
  </div>
  <!-- /.bl_codeBlock -->


        <h5 id="modifier_block" class="el_lv5Heading">ブロックモジュールの例</h5>
        <p>
          ブロックモジュールのモディファイアによる変更パターンについては、
        </p>
        <ul>
          <li>特定の子要素のみにモディファイアを付加する</li>
          <li>ブロックモジュールのルート要素にモディファイアを付加する</li>
        </ul>
        <p>
          の2通りのパターンがあげられます。<br>
          前者の場合はセオリー通り複数クラス指定をすることにより、後者の場合はモディファイア名と子（孫）結合子を使用することにより、詳細度を高めます。<br>
          後者の方法はルート要素に付与した1つのモディファイアで、複数の子要素のスタイルを変更したい場合に最適です。
        </p>
        <p>
          次の例は
        </p>
        <ul>
          <li>特定の子要素のみにモディファイアを付加する → 画像にボーダーを付ける</li>
          <li>ブロックモジュールのルート要素にモディファイアを付加する → 左右反転させる</li>
        </ul>
        <p>
          のデモです。
        </p>
        <iframe title="ブロックモジュールに対するモディファイアの付け方の2つのパターン" loading="lazy" class="el_iframe js_iframe" src="/sample/modifier.html" onload="resizeIframe(this)"></iframe>
        
        
  <div class="bl_codeBlock">
    <em class="bl_codeBlock_ttl">HTML</em>
    <pre class="brush:html; class-name:''; highlight:[3,15]">
      
          &lt;!-- 特定の子要素のみにモディファイアを適用する場合 --&gt;
          &lt;div class=&#34;bl_media&#34;&gt;
            &lt;figure class=&#34;bl_media_imgWrapper bl_media_imgWrapper__bordered&#34;&gt;
              &lt;img alt=&#34;Dummy Image&#34; src=&#34;https://picsum.photos/640/426&#34;&gt;
            &lt;/figure&gt;
            &lt;div class=&#34;bl_media_body&#34;&gt;
              &lt;h3 class=&#34;bl_media_ttl&#34;&gt;TITLE HERE&lt;/h3&gt;
              &lt;p class=&#34;bl_media_txt&#34;&gt; ... &lt;/p&gt;
            &lt;/div&gt;
            &lt;!-- /.bl_media_body --&gt;
          &lt;/div&gt;
          &lt;!-- /.bl_media --&gt;

          &lt;!-- 子要素複数に対してスタイルを上書きする例 --&gt;
          &lt;div class=&#34;bl_media bl_media__rev&#34;&gt;
            &lt;figure class=&#34;bl_media_imgWrapper&#34;&gt;
              &lt;img alt=&#34;Dummy Image&#34; src=&#34;https://picsum.photos/641/426&#34;&gt;
            &lt;/figure&gt;
            &lt;div class=&#34;bl_media_body&#34;&gt;
              &lt;h3 class=&#34;bl_media_ttl&#34;&gt;TITLE HERE&lt;/h3&gt;
              &lt;p class=&#34;bl_media_txt&#34;&gt; ... &lt;/p&gt;
            &lt;/div&gt;
            &lt;!-- /.bl_media_body --&gt;
          &lt;/div&gt;
          &lt;!-- /.bl_media --&gt;
    </pre>
  </div>
  <!-- /.bl_codeBlock -->

        
        
  <div class="bl_codeBlock">
    <em class="bl_codeBlock_ttl">CSS</em>
    <pre class="brush:css; class-name:''; highlight:[]">
      
          // 特定の子要素のみにモディファイアを適用する場合
          .bl_media_imgWrapper.bl_media_imgWrapper__bordered {
            padding: 5px;
            border: 1px solid #000;
          }

          // 子要素複数に対してスタイルを上書きする例
          .bl_media.bl_media__rev {
            flex-direction: row-reverse;
          }

          .bl_media__rev .bl_media_imgWrapper {
            margin-right: 0;
          }

          .bl_media__rev .bl_media_body {
            margin-right: 3.33333%;
            text-align: right;
          }
    </pre>
  </div>
  <!-- /.bl_codeBlock -->

        <p>
          後者はさておき、前者の特定の子要素のみに変更を加えたいときに、モジュールのルート要素にモディファイアを付加することは推奨しません。モディファイアのスコープが広がり、他の子要素まで制御している可能性があるように見えてしまうからです。
        </p>
        
        
  <div class="bl_codeBlock">
    <em class="bl_codeBlock_ttl">× 特定の子要素のみの変更にも関わらず、モジュールのルート要素にモディファイアを付加している</em>
    <pre class="brush:css; class-name:'light'; highlight:[1]">
      
          &lt;div class=&#34;bl_media bl_media__imgBordered&#34;&gt;
            &lt;figure class=&#34;bl_media_imgWrapper bl_media_imgWrapper__bordered&#34;&gt;
              &lt;img alt=&#34;Dummy Image&#34; src=&#34;https://picsum.photos/640/426&#34;&gt;
            &lt;/figure&gt;
            &lt;div class=&#34;bl_media_body&#34;&gt;
              &lt;h3 class=&#34;bl_media_ttl&#34;&gt;TITLE HERE&lt;/h3&gt;
              &lt;p class=&#34;bl_media_txt&#34;&gt; ... &lt;/p&gt;
            &lt;/div&gt;
            &lt;!-- /.bl_media_body --&gt;
          &lt;/div&gt;
          &lt;!-- /.bl_media --&gt;
    </pre>
  </div>
  <!-- /.bl_codeBlock -->


        <p>
          また繰り返しになりますが、ブロックモジュールそれ自体の大きさの変化に対して、モディファイアを付加することはあまり推奨しません。ブロックモジュールの表示サイズは移植先のコンテキストにより頻繁に変わる可能性があり、ブロックモジュールはエレメントモジュールに比べバリエーションが不定になりがちだからです。
        </p>
        <p>
          これも繰り返しになりますが、ブロックモジュールが他所のモジュール内にネストされ、かつレイアウトの調整が必要な場合は、コンテキストからの制御を推奨します。（詳しくは<a href="#advance">Advance Case</a>にて解説しています）
        </p>

        <h3 class="el_lv3Heading">4.ヘルパー</h3>
        <p>
          <b>接頭辞：hp_（helperの略）</b>
        </p>
        <p>
          基本的に1つのスタイルのみで、意図的な上書きのため
          <code>!important</code>
          を付加することを推奨します。命名規則に関してはモディファイアと同様「
          <code>keyValue</code>
          」の形を取り、省略する場合は<a href="//docs.emmet.io/cheat-sheet/" target="_blank" rel="noopener">Emmetのチートシート</a>に準ずることを推奨します。<br>
          その他の規則として
        </p>
        <ul>
          <li>px以外の単位の場合は分かりやすい頭文字で表現</li>
          <li>小数点はアンダースコアで表現</li>
          <li>ネガティブな値はショートハンドを大文字で表現</li>
          <li>ショートハンドの後に文字列が続く場合はキャメルケースで表現</li>
        </ul>
        <p>
          とします（これらの規則はモディファイアの命名にも概ね有効です）。<br>
          ただし1つの要素に対しヘルパーを多用し過ぎると、style属性を使用していることと変わりが無くなってしまうので、<em>ヘルパーが3つ以上になった場合はモジュール化を検討するべきでしょう</em>。
        </p>
        <p>
          基本的に1スタイルのみのため、1行で記載することを許容します。
          また挙動が限定的でかつ明確な場合のみ、1つ以上のスタイルであってもヘルパーで処理することが可能です。
        </p>
        
        
  <div class="bl_codeBlock">
    <em class="bl_codeBlock_ttl">CSS</em>
    <pre class="brush:css; class-name:''; highlight:[]">
      
            .hp_db { display: block !important; }
            .hp_tac { text-align: center !important; }
            .hp_w400 { width: 400px !important; }
            .hp_w50p { width: 50% !important; }
            .hp_lh1_5 { line-height: 1.5 !important; }
            .hp_MT1e { margin-top: -1em !important; }
            .hp_bgcWhite { background-color: #fff !important; }

            //1つ以上のスタイルの例
            .hp_centering {
              display: block !important;
              margin-left: auto !important;
              margin-right: auto !important;
            }
    </pre>
  </div>
  <!-- /.bl_codeBlock -->


        <h5 id="helper_clearfix" class="el_lv4Heading">clearfixについて</h5>
        <p>
          そもそも、もうあまりfloatでレイアウトを行うこと自体少ないと思いますが、万が一floatを用いてレイアウトを行う場合、PRECSSではfloatの解除にclearfixを推奨します。これは、floatの解除のためだけに本来の目的とは関係の無いスタイルを記述することを忌避するためです。<br>
          特にoverflowは本来の目的で使われる場合もあり、CSSコードだけ見たときに、それがfloatの解除のためなのか、本来の目的のためなのかわからない、といった状況は好ましくありません。<br>
          またPRECSSのルールに当てはめればclearfixもヘルパーとして定義することが可能ですが、clearfixはそれ自体が充分に一般的であり誰が見ても役割を把握できるため、無理に接頭辞を付けなくても構いません。
        </p>

          <h3 id="unique" class="el_lv3Heading">5.ユニーク</h3>
          <p>
            <b>接頭辞：un_（uniqueの略）</b>
          </p>
          <p>
            ある1ページでしか使用されていないことを明示するグループです。ECSS以外のCSSアーキテクチャで、不要になれば臆せず捨てられるスタイルの目印を用意しているのが、PRECSSの大きな特徴の1つです。<br>
            そのページでしか使われていないため、改修や運用の際に影響範囲を気にせずにスタイルを編集してよい目印になっています。<br>
            モジュールの大きさも自由です。小さくても大きくてもかまいせん。
          </p>
          <p>
            例えば<a href="/" target="_blank" rel="noopener">PRECSSの扉ページ</a>のような特別なページに使用するのもいいですし、通常のページ内でもモジュール設計から外れる場所（例えば
            <code>postion: absolute;</code>
            を乱発するような）に使用するのもいいでしょう。<br>
            つまりユニークグループは、あらゆるイレギュラーのための万能な回避策です。<br>
            何か迷ったら、とりあえずユニークグループを使ってください。いつでも誰でも、すぐに手直ししてよい目印です。<br>
            ただし濫用し過ぎると拡張性に欠けるため、あくまでイレギュラーのための措置であることを覚えておいてください。
          </p>
          <p>
            またCSSには、どのページで使用しているかコメントを残しておくとよりよいでしょう。
          </p>
          
          
  <div class="bl_codeBlock">
    <em class="bl_codeBlock_ttl">HTML</em>
    <pre class="brush:html; class-name:''; highlight:[]">
      
              &lt;div class=&#34;un_siteRoot_wrapper&#34;&gt;
                &lt;section class=&#34;un_siteRoot&#34;&gt;
                  &lt;p class=&#34;un_siteRoot_logo&#34;&gt;&lt;img src=&#34;images/icon.svg&#34; alt=&#34;PRECSS logo&#34;&gt;&lt;/p&gt;
                  &lt;h1 class=&#34;un_siteRoot_ttl&#34;&gt;PRECSS&lt;/h1&gt;
                  &lt;p class=&#34;un_siteRoot_link&#34;&gt;&lt;span class=&#34;is_deactive&#34;&gt;English&lt;/span&gt; / &lt;a href=&#34;/ja/&#34;&gt;日本語&lt;/a&gt;&lt;/p&gt;
                &lt;/section&gt;
              &lt;/div&gt;
    </pre>
  </div>
  <!-- /.bl_codeBlock -->

          
          
  <div class="bl_codeBlock">
    <em class="bl_codeBlock_ttl">○(CSS)</em>
    <pre class="brush:css; class-name:''; highlight:[]">
      
              //トップページ（/）に使用
              .un_siteRoot_wrapper {
                position: relative;
                top: 33vh;
                text-align: center;
              }
              .un_siteRoot {
                display: inline-block;
              }...
    </pre>
  </div>
  <!-- /.bl_codeBlock -->


          <h3 id="program" class="el_lv3Heading">6.プログラム</h3>
          <p>
            PRECSSではJavaScript等のプログラムで要素にタッチする際、または状態を管理する際、専用のクラスを付加しモジュールのクラスとは分離することを推奨します。
          </p>
          <p>
            <b>接頭辞：js_（JavaScriptの略）</b>
          </p>
          <p>
            JavaScriptにて要素を取得するためのクラスです。
          </p>
          <p>
            <b>接頭辞：is_（英語のbe動詞のisから）</b>
          </p>
          <p>
            要素の状態を管理するためのクラスです。必ず適用されなければならないスタイルであるため、
            <code>!important</code>
            の使用も推奨します。<br>
            状態の命名は
            <code>is_active</code>
            とシンプルに記述することが可能ですが、他の箇所にも影響を及ぼさないよう<em>必ず複数クラスでスタイルを適用</em>する必要があります。
          </p>
          <p>
            またプログラムグループを用いて実現したいような挙動に関しては、これら2つの接頭辞ではなく、カスタムデータ属性やWAI-ARIAを使用することも許容します。
          </p>

          <iframe title="プログラムグループの例" loading="lazy" class="el_iframe js_iframe" src="/sample/program.html" onload="resizeIframe(this)"></iframe>
          
          
  <div class="bl_codeBlock">
    <em class="bl_codeBlock_ttl">HTML</em>
    <pre class="brush:html; class-name:''; highlight:[1,3,5]">
      
            &lt;dl class=&#34;bl_accordion js_accordion&#34;&gt;
              &lt;dt&gt;
                &lt;button class=&#34;bl_accordion_btn js_accordion_ttl is_active&#34; type=&#34;button&#34;&gt;TITLE HERE&lt;/button&gt;
              &lt;/dt&gt;
              &lt;dd class=&#34;bl_accordion_body js_accordion_body is_active&#34;&gt;
                &lt;p class=&#34;bl_accordion_txt&#34;&gt;
                  Lorem ipsum dolor sit amet, consectetur adipisicing elit. Nesciunt, voluptates!
                &lt;/p&gt;
              &lt;/dd&gt;
            &lt;/dl&gt;
    </pre>
  </div>
  <!-- /.bl_codeBlock -->

          
          
  <div class="bl_codeBlock">
    <em class="bl_codeBlock_ttl">× .is_activeの有効範囲が広すぎる</em>
    <pre class="brush:css; class-name:'light'; highlight:[5]">
      
              .js_accordion_body {
                display: none;
              }
              //他の箇所にまで影響を及ぼす可能性がある
              .is_active {
                display: block;
              }
    </pre>
  </div>
  <!-- /.bl_codeBlock -->

          
          
  <div class="bl_codeBlock">
    <em class="bl_codeBlock_ttl">○ .is_activeの有効範囲が適切</em>
    <pre class="brush:css; class-name:''; highlight:[4]">
      
              .js_accordion_body {
                display: none;
              }
              .js_accordion_body.is_active {
                display: block;
              }
    </pre>
  </div>
  <!-- /.bl_codeBlock -->


          <p>
            なお表示 / 非表示程度のシンプルな制御であれば、上記のコードの通り
            <code>.js_</code>
            接頭辞のクラスに対するスタイリングで事足ります。しかしモジュールによっては、<em>「表示 / 非表示の状態によって、アイコンも変わる」</em>など、複雑なスタイリングが必要なこともあるでしょう。<br>
            そういった場合は、
            <code>.js_</code>
            クラスと
            <code>.is_</code>
            クラスの組み合わせでなく、
            <code>.bl_</code>
            クラスと
            <code>.is_</code>
            クラスの組み合わせでスタイリングを行うことも可能です。今回のアコーディオンのCSSも、実際には次のようになっています。
          </p>
          
          
  <div class="bl_codeBlock">
    <em class="bl_codeBlock_ttl">○ .bl_と.is_を組み合わせた例</em>
    <pre class="brush:css; class-name:''; highlight:[26,34]">
      
            // 横棒の生成
            .bl_accordion_btn::before {
              content: &#39;&#39;;
              position: absolute;
              top: 50%;
              right: 15px;
              display: block;
              width: 20px;
              height: 2px;
              background-color: currentColor;
              transform: translateY(-50%);
            }
            // 縦棒の生成
            .bl_accordion_btn::after {
              content: &#39;&#39;;
              position: absolute;
              top: 50%;
              right: 24px;
              display: block;
              width: 2px;
              height: 20px;
              background-color: currentColor;
              transform: translateY(-50%);
            }
            // .is_active時は縦棒を無くし、マイナスアイコンに見せる
            .bl_accordion_btn.is_active::after {
              content: none;
            }

            .bl_accordion_body {
              display: none;
            }

            .bl_accordion_body.is_active {
              display: block;
            }
    </pre>
  </div>
  <!-- /.bl_codeBlock -->

          <p>
            重要なのは、1つのモジュールに関するスタイリングで
            <code>.js_&.is_</code>
            と
            <code>.bl_&.is_</code>
            を混在させないことです。上記のコード例で言えば「アイコンのアクティブ表示は
            <code>.bl_&.is_</code>
            なのに、ボディのアクティブ表示は
            <code>.js_&.is_</code>
            となっている」という状況は混乱の元なので、1つのモジュール内においては
            <code>.is_</code>
            を
            <code>.js_</code>
            と組み合わせるか、
            <code>.bl_</code>
            と組み合わせるかは必ず統一しましょう。
          </p>

          <h3 id="original" class="el_lv3Heading">7.オリジナル</h3>
          <p>
            その他、サイトの構築思想に応じて柔軟に接頭辞を追加できるのがPRECSSの特徴です。 <br>例えばオリジナルのグリッドシステムを構築する場合、gridの略として
            <code>.gr_4</code>
            、
            <code>gr_6</code>
            やcolumnの略として
            <code>.cl_4</code>
            、
            <code>cl_6</code>
            といった接頭辞を追加することができます。<br>
            デスクトップ幅のみに有効なクラスは
            <code>.lg_**（largeの略）</code>
            、タブレット幅以下のみ有効なクラスは
            <code>.md_**（mediumの略）</code>
            、スマートフォン幅以下のみ有効なクラスは
            <code>.sm_**（smallの略）</code>
            とするのもいいでしょう。
          </p>
          <p>
            またPRECSSの命名規則が使えるのは、HTML/CSS/JavaScriptに限りません。テンプレートエンジンやビルド環境、或いはCMSテンプレートにもPRECSSの命名規則を活かすことができます。<br>
            例えばWordPressのメソッドに依存してるmacroやmixinがある場合は、
            <code>wp_</code>
            という接頭辞を付けておくと、名前を見るだけでWordPressの処理が絡んでいることが予測できます。MovableTypeなら
            <code>mt_</code>
            、Drupalなら
            <code>dr_</code>
            、a-blog cmsなら
            <code>ac_</code>
            、HubSpot CMSなら
            <code>hs_</code>
            という具合になります。
          </p>
          <p>
            言語やテンプレートエンジンによっては変数名にハイフンが使用できないものもありますが、PRECSSではハイフンを使用しないため、開発環境全体を通して命名規則を統一することも可能です。一定の法則に従っている限り、PRECSS はどのように拡張してもらっても構いません
          </p>
        </section>
        <!-- /.bl_sect bl_wysiwyg -->
      </div>
      <!-- /.ly_body -->

      <div class="bl_sectBlockCalm">
        <p class="bl_sectBlockCalm_txt">Advance Case</p>
      </div>
          <!-- /.bl_sectBlockCalm -->

      <div class="ly_cont">
        <section id="nestedModule" class="bl_sect bl_wysiwyg">
          <h2 class="el_lv2Heading">モジュールが他のモジュールにネストされる場合</h2>
          <p>
            PRECSSでは一つのブロックモジュール内に他のブロックモジュール、またはエレメントモジュールがネストされることがあります。これは、モジュールが「どこでも再利用されるべきもの」である思想の下の正しい挙動です。<br>
            その際に直面する、主にレイアウトの問題について、幾つか指針を示します。<br>
            現在構築中のモジュールをアコーディオン（
            <code>.bl_accordion</code>
            ）、既に他所で構築済みで、アコーディオンに埋め込みたいモジュールをメディア（
            <code>.bl_media</code>
            ）としましょう。<br>
            基本的な原則は、以下の2つのみです。
          </p>
          <ol>
            <li>埋め込まれたモジュール（メディア）のレイアウトは、コンテキスト（アコーディオン）から制御する</li>
            <li>埋め込まれたモジュール（メディア）内の子要素は、コンテキスト（アコーディオン）から制御してはならない</li>
          </ol>

          <h3 class="el_lv3Heading" id="principal">原則1. 埋め込まれたモジュール（メディア）のレイアウトは、コンテキスト（アコーディオン）から制御する</h3>
          <p>
            まず1つ目の原則です。例えばアコーディオン内にメディアを埋め込んだ際、
          </p>
          <ul>
            <li>メディアの横幅を90%に</li>
            <li>かつ、左右中央揃えに</li>
          </ul>
          <p>
            したいとしましょう。次のような表示です。
          </p>
          <iframe title="アコーディオン内にメディアを埋め込んだ例" loading="lazy" class="el_iframe js_iframe" src="/sample/advance.html" onload="resizeIframe(this)"></iframe>
          <p>
            この実装方法に関しては、次のいずれかを推奨します。
          </p>
          <ul>
            <li>コンテキスト（アコーディオン）の子要素（BEMでいうElementのMix）を作成し、その要素にスタイリングをする</li>
            <li>コンテキスト（アコーディオン）のクラス名と埋め込まれたモジュール（メディア）のクラス名、子（孫）結合子を使用してスタイリングする</li>
          </ul>
          <p>
            それぞれのパターンのコードの例を次に示します。
          </p>

          <h4 class="el_lv4Heading">ⅰ.コンテキストの子要素を作成し、その要素にスタイリングをする</h4>
          
          
  <div class="bl_codeBlock">
    <em class="bl_codeBlock_ttl">bl_accordion_mediaというクラス名を追加</em>
    <pre class="brush:html; class-name:''; highlight:[4]">
      
            &lt;dd class=&#34;bl_accordion_body js_accordion_body is_active&#34;&gt;
              &lt;p class=&#34;bl_accordion_txt&#34;&gt; ... &lt;/p&gt;
              &lt;!-- .bl_accordion_mediaの追加 --&gt;
              &lt;div class=&#34;bl_accordion_media bl_media&#34;&gt;
                （bl_mediaの内容）
              &lt;/div&gt;
              &lt;!-- /.bl_accordion_media bl_media --&gt;
            &lt;/dd&gt;
    </pre>
  </div>
  <!-- /.bl_codeBlock -->

          
          
  <div class="bl_codeBlock">
    <em class="bl_codeBlock_ttl">.bl_accordion_mediaに対してスタイリングを行う</em>
    <pre class="brush:css; class-name:''; highlight:[7]">
      
            // メディアの元のスタイリング
            .bl_media {
              display: flex;
              align-items: center;
            }
            // 今回追加したスタイリング
            .bl_accordion_media {
              width: 90%;
              margin-right: auto;
              margin-left: auto;
            }
    </pre>
  </div>
  <!-- /.bl_codeBlock -->


          <p>
            <code>.bl_media</code>
            と同一のdiv要素に
            <code>.bl_accordion_media</code>
            を付与しました。スタイリングも
            <code>.bl_accordion_media</code>
            にしていますので、アコーディオンとメディアは疎結合な関係となり、仮にメディアのクラス名を
            <code>.bl_media</code>
            から変更しても、アコーディオン内のメディアの表示にはなんら影響しません。
          </p>
          <p>
            ただしこのパターンにはちょっとした弱点があります。<br>
            CSSを見ると
            <code>.bl_media</code>
            と
            <code>.bl_accordion_media</code>
            は同等の詳細度であるため、同一のプロパティがある場合、後に宣言された方が優先されます。仮に
            <code>.bl_media</code>
            に
            <code>margin-bottom: 40px;</code>
            が既に指定されており、かつアコーディオン内では
            <code>margin-bottom: 20px;</code>
            を適用したければ、必ず
            <code>.bl_accordion_media</code>
            の宣言が後に来なければなりません。この宣言順の管理は、モジュールの数が増えれば増えるほどとても煩雑なものとなります。
          </p>
          <p>
            本来はブロックモジュールにレイアウトに関わるプロパティがなるべく宣言されていないのが望ましいのですが、実際の現場ではそうもいかないこともあるでしょう。<br>
            このコンフリクトに関しては詳細度を高くすればひとまず解決しますので、次のように
            <code>:not()</code>
            擬似クラスを利用して解決することも可能です。
          </p>

          
          
  <div class="bl_codeBlock">
    <em class="bl_codeBlock_ttl">:not()擬似クラスを利用することで詳細度を高める</em>
    <pre class="brush:css; class-name:''; highlight:[2]">
      
            .bl_accordion_media:not(.hoge) {
              margin-bottom: 20px; // こちらが適用される
            }

            .bl_media{
              margin-bottom: 40px;
            }
    </pre>
  </div>
  <!-- /.bl_codeBlock -->

          <p>
            ただしこの方法はハックの域を出ませんので、よく思わない方もいるでしょう。他には、モジュールのルート要素をセレクタに含んで詳細度を高める方法もあります。
          </p>
          
          
  <div class="bl_codeBlock">
    <em class="bl_codeBlock_ttl">モジュールのルート要素を利用することで詳細度を高める</em>
    <pre class="brush:css; class-name:''; highlight:[2]">
      
            .bl_accordion .bl_accordion_media {
              margin-bottom: 20px; // こちらが適用される
            }

            .bl_media{
              margin-bottom: 40px;
            }
    </pre>
  </div>
  <!-- /.bl_codeBlock -->

          <p>
            ただし
            <code>.bl_accordion</code>
            の他の子要素は詳細度が単一のクラスセレクタのみでフラットに保たれていますので、CSSだけ見るとここだけ詳細度がいきなり高くなるのは、どうもひっかかります。<br>
            次の方法では、これらの問題を簡単に解決できます。
          </p>


          <h4 class="el_lv4Heading">ⅱ.コンテキストのクラス名と埋め込まれたモジュールのクラス名、子（孫）結合子を使用してスタイリングする</h4>
          
          
  <div class="bl_codeBlock">
    <em class="bl_codeBlock_ttl">HTMLでは埋め込むだけで特に何もしない</em>
    <pre class="brush:html; class-name:''; highlight:[]">
      
            &lt;dd class=&#34;bl_accordion_body js_accordion_body is_active&#34;&gt;
              &lt;p class=&#34;bl_accordion_txt&#34;&gt; ... &lt;/p&gt;
              &lt;div class=&#34;bl_media&#34;&gt;
                （bl_mediaの内容）
              &lt;/div&gt;
              &lt;!-- /.bl_accordion_media bl_media --&gt;
            &lt;/dd&gt;
    </pre>
  </div>
  <!-- /.bl_codeBlock -->

          
          
  <div class="bl_codeBlock">
    <em class="bl_codeBlock_ttl">コンテキスト、埋め込まれたモジュールそれぞれの名前を使う</em>
    <pre class="brush:css; class-name:''; highlight:[1]">
      
            .bl_accordion .bl_media {
              width: 90%;
              margin-right: auto;
              margin-left: auto;
            }
    </pre>
  </div>
  <!-- /.bl_codeBlock -->

          <p>
            <code>.bl_accordion</code>
            の名前と
            <code>.bl_media</code>
            、子孫結合子を使用してスタイリングしました。詳細度が高いため、
            <code>.bl_media</code>
            の元のスタイリングとの宣言順も気にする必要がありません。また新たにクラスを作成しなくて良いので、単純に楽です。
          </p>
          <p>
            しかし一方で、この方法はアコーディオンとメディアが完全に疎結合とは言えません。メディアのクラス名が
            <code>.bl_media</code>
            から変更になると、先ほどの例では問題なかったのに対し、こちらの例ではアコーディオン内のメディアに対するスタイリングが効かなくなります。そのためモジュール名変更の際は、このような依存関係をプロジェクト全体に渡り横断検索し確認しなければなりません（とはいえ、モジュールの依存に関わらず普通は一度は横断検索するでしょうが）。
          </p>
          <p>
            結局どちらの方法が良いとは一概には言えませんが、前者の方法では「メディアを埋め込むも、
            <code>.bl_accordion_media</code>
            のクラス名を付け忘れる」というリスクもありますので、運用中の事故やストレスが少ないのは後者でしょう。なるべく途中からモジュール名を変える必要がないよう、モジュールの命名時に熟考したいところです。
          </p>

          <h3 class="el_lv3Heading" id="principal2">原則2. 埋め込まれたモジュール（メディア）内の子要素は、コンテキスト（アコーディオン）から制御してはならない</h3>
          <p>
            メディアをアコーディオンに埋め込んだ際にメディアの子要素に何らかの変更が必要な場合、
            <code>.bl_accordion .bl_media_**</code>
            という形でスタイルを上書きしてはいけません。また、メディアの子要素にアコーディオンの子要素クラスを追加することも推奨しません。<br>
            これはモジュールブロックそれ自体が、<em>単独で完結すべき1つの塊</em>という思想であるからです。塊それ自体のレイアウトがコンテキストにより挙動を変えるのは可能ですが、その子要素までもがコンテキストに影響されるのは好ましくありません。今回の例で言えばメディアの内部についてはメディアのみが責任を持つべきで、つまり<em>ブロックモジュール内は、そのブロックモジュール以外からの変更を受けない聖域</em>と考えます。
          </p>
          <p>
            メディアをアコーディオンへ埋め込んだ際にメディアの内部に変更が必要な場合は、メディアのモディファイア作成して処理します。ここでは、メディア内のフォントサイズが全体的に小さくなる例を示します。
          </p>
          <iframe title="アコーディオン内のメディアはフォントサイズを小さくする例" loading="lazy" class="el_iframe js_iframe" src="/sample/advance2.html" onload="resizeIframe(this)"></iframe>
          
          
  <div class="bl_codeBlock">
    <em class="bl_codeBlock_ttl">bl_media__fzSmモディファイアの追加</em>
    <pre class="brush:html; class-name:''; highlight:[3]">
      
            &lt;dd class=&#34;bl_accordion_body js_accordion_body is_active&#34;&gt;
              &lt;p class=&#34;bl_accordion_txt&#34;&gt; ... &lt;/p&gt;
              &lt;div class=&#34;bl_media bl_media__fzSm&#34;&gt;
                （bl_mediaの内容）
              &lt;/div&gt;
              &lt;!-- /.bl_accordion_media bl_media --&gt;
            &lt;/dd&gt;
    </pre>
  </div>
  <!-- /.bl_codeBlock -->

          
          
  <div class="bl_codeBlock">
    <em class="bl_codeBlock_ttl">.bl_media__fzSmモディファイアに対してスタイリングを行う</em>
    <pre class="brush:css; class-name:''; highlight:[]">
      
            .bl_media__fzSm .bl_media_ttl {
              font-size: .875rem;
            }
            .bl_media__fzSm .bl_media_txt {
              font-size: .8125rem;
            }
    </pre>
  </div>
  <!-- /.bl_codeBlock -->

          <p>
            このように記述する最大のメリットは、<em>責任範囲の明確なコードを維持できること</em>にあります。仮にコンテキスト（アコーディオン）からメディア内の子要素に対してコントロールを行っていると、アコーディオンの改修に際しメディアの子要素に不具合が起きる可能性があります。そのようなコンテキストと埋め込まれたモジュールが密結合な状態は好ましくありません。<br>
            モジュールの責任範囲を明確にしておくことのメリットは、メンテナンス性の高さだけではありません。仮にフォントサイズの小さいメディアをアコーディオンとは違う箇所で使用したい場合も、モディファイアを付ければ、いつでもどこでもすぐに同じ状態を再現できます。
          </p>
        </section>
        <!-- /.bl_sectBlock -->
      </div>
      <!-- /.ly_body -->
    </main>
  </article>

  <footer class="ly_footer">
    <div class="ly_footer_inner">
      <p class="el_centerTxt">
        PRECSS is maintained and funded by assialiholic.<br>
        Contributors &amp; Transrators wanted!<br>
        <a title="GitHub" href="//github.com/assialiholic/precss/" target="_blank" rel="noopener"><i class="fab fa-github fa-3x" aria-hidden="true"></i></a>
      </p>
    </div>
    <!-- /.ly_footer_inner -->
  </footer>
</body>
</html>
