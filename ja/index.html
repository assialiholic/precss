
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>PRECSS - Manage your CSS with prefixes.</title>
  <meta name="description" content="PRECSS is a new modular architecture approach based on OOCSS, SMACSS and BEM.">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta property="og:type" content="website" />
  <meta property="og:site_name" content="PRECSS - Manage your CSS with prefixes." />
  <meta property="og:url" content="http://precss.io/" />
  <meta property="og:image" content="http://precss.io/images/ogimage.png" />
  <meta property="og:description" content="PRECSS is a new modular architecture approach based on OOCSS, SMACSS and BEM." />
  <meta name="twitter:card" content="summary_large_image" />
  <meta name="twitter:title" content="PRECSS - Manage your CSS with prefixes." />
  <meta name="twitter:domain" content="precss.io">
  <meta name="twitter:image" content="http://precss.io/images/ogimage.png" />
  <meta name="twitter:description" content="PRECSS is a new modular architecture approach based on OOCSS, SMACSS and BEM.">
  <link rel="shortcut icon" href="/images/favicon.ico" />
  <link rel="stylesheet" href="/css/main.css">
  <script defer src="//use.fontawesome.com/releases/v5.0.9/js/all.js" integrity="sha384-8iPTk2s/jMVj81dnzb/iFR2sdA7u06vHJyyLlAd4snFpCl/SnyUjRrbdJsw1pGIl" crossorigin="anonymous"></script>
  <link href='//fonts.googleapis.com/css?family=Source+Sans+Pro|Rokkitt' rel='stylesheet' type='text/css'>
</head>
<body>
<header class="ly_header">
    <div class="ly_header_inner">
      <div class="bl_headerConts">
        <p class="bl_headerConts_logo"><img src="/images/logo.svg" alt="PRE_CSS"></p>
        <ul class="bl_headerConts_nav">
          <li><i class="fab fa-github" aria-hidden="true"></i><a href="//github.com/assialiholic/precss/" target="_blank">GitHub</a></li>
        </ul>
      </div>
      <!-- /.bl_headerConts -->
    </div>
    <!-- /.ly_header_inner -->
    <section class="bl_MV">
      <div class="bl_MV_inner">
        <h1 class="bl_MV_ttl">Manage your CSS<br>with prefixes.</h1>
        <!-- <p class="bl_MV_img"><img src="/images/MV.png" alt=""></p> -->
        <pre class="bl_MV_code js_split">
          &lt;div class="<span class="hp_cBlue">ly_header</span>"&gt;...&lt;/div&gt;&nbsp;&nbsp;<span class="hp_cGray hp_fsi">&lt;!-- layout --&gt;</span>
          &lt;div class="<span class="hp_cBlue">ly_main</span>"&gt;
              &lt;div class="<span class="hp_cGreen">bl_jumbotron</span>"&gt;&nbsp;&nbsp;<span class="hp_cGray hp_fsi">&lt;!-- block module --&gt;</span>
                  &lt;h2 class="<span class="hp_cGreen">bl_jumbotron_ttl</span>"&gt;PRECSS&lt;/h2&gt;
                  &lt;p class="<span class="hp_cGreen">bl_jumbotron_txt</span> <span class="hp_cViolet">hp_mb20</span>"&gt;CSS with prefixes.&lt;/p&gt;&nbsp;&nbsp;<span class="hp_cGray hp_fsi">&lt;!-- helper --&gt;</span>
              &lt;/div&gt;
          &lt;/div&gt;
          &lt;div class="<span class="hp_cBlue">ly_side</span>"&gt;
              &lt;a href="#" class="<span class="hp_cOrange">el_btn</span>"&gt;Try PRECSS&lt;/a&gt;&nbsp;&nbsp;<span class="hp_cGray hp_fsi">&lt;!-- element module --&gt;</span>
              &lt;a href="#" class="<span class="hp_cOrange">el_btn</span> <span class="hp_cRed">el_btn__blue</span>"&gt;Back&lt;/a&gt;&nbsp;&nbsp;<span class="hp_cGray hp_fsi">&lt;!-- modifier --&gt;</span>
          &lt;/div&gt;
          &lt;div class="<span class="hp_cBlue">ly_footer</span>"&gt;...&lt;/div&gt;
        </pre>
      </div>
      <!-- /.bl_MV_inner -->
    </section>
    <!-- /.bl_MV -->
</header>
<article>
  <div class="ly_main">
    <div class="ly_main_inner">
      <section class="bl_catch">
        <h2 class="bl_catch_head">OOCSSやSMACSS、BEMの素晴らしさ巧みに取り入れ<br>更に進化させた強力なモジュール設計。それがPRECSSです。</h2>
        <div class="bl_featureUnit bl_featureUnit__col2 cf">
          <dl class="bl_featureBlock">
            <dt><i class="fas fa-sort-alpha-down hp_fz1_5e" aria-hidden="true"></i><br>全てに接頭辞を付加</dt>
            <dd>
              PRECSSの管理下にあるクラスは、全て種類に応じた接頭辞が付加されます。これにより接頭辞を一目見ただけで役割、スコープを把握することができます。<br>
              もうモジュールの粒度に悩まないでください。
            </dd>
          </dl>
          <dl class="bl_featureBlock">
            <dt><i class="fa fa-check-circle hp_fz1_3e" aria-hidden="true"></i><br>シンプルな命名規則</dt>
            <dd>
              クラス名は全てスネークケースとキャメルケースの混成で構成され、それらの使い分けには明確なルールがあります。<br>
              省略語についても指針を示しているため、今までのように悩んだあげく、とても長い名前を付ける必要はもうありません。
            </dd>
          </dl>
        </div>
        <!-- /.bl_featureUnit -->
        <div class="bl_featureUnit bl_featureUnit__col3 cf">
          <dl class="bl_featureBlock">
            <dt class="js_matchHeight"><i class="fa fa-heart hp_fz1_3e" aria-hidden="true"></i><br>親しみやすい設計</dt>
            <dd>
              PRECSSは全く新しい設計思想ではありません。OOCSSやSMACSS、BEMなど今までの賞賛すべき素晴らしい思想が基になっています。<br>あなたがモダンな開発者であるほど、PRECSSは親しみやすいものに感じるでしょう。
            </dd>
          </dl>
          <dl class="bl_featureBlock">
            <dt class="js_matchHeight"><i class="fa fa-users hp_fz1_5e" aria-hidden="true"></i><br>他種族との共存</dt>
            <dd>
              明確な独自記法により、あなたが書いたクラスとCMSやCSSフレームワークが出力したクラスを明確に区別することができるでしょう。<br>
              全てPRECSSのルールに従わなければならないのではなく、他の者も受け入れる柔軟さがPRECSSにはあります。
            </dd>
          </dl>
          <dl class="bl_featureBlock">
            <dt class="js_matchHeight"><i class="fas fa-expand-arrows-alt hp_fz1_3e" aria-hidden="true"></i><br>拡張可能</dt>
            <dd>
              スマートフォンのみに有効なクラスが必要になった場合は、「.sp_**」という接頭辞を持つグループを作るのもよいでしょう。<br>
              PRECSSは基本的にそれぞれ独自の接頭辞を持つ6つのグループから成り立っていますが、必要に応じて拡張も可能です。
            </dd>
          </dl>
        </div>
        <!-- /.bl_featureUnit bl_featureUnit__col3 -->
      </section>
    </div>
    <!-- /.ly_main_inner -->
  </div>
  <!-- /.ly_main -->

  <nav class="ly_stickySide js_stickySide js_closeParent">
    <div class="js_stickyInner">
      <a href="close" class="el_closeBtn js_closeBtn">×</a>
      <ul class="bl_utickyList">
      <li><a href="#rule">記法</a></li>
      <li class="hp_mb30"><a href="#nameRule">命名規則</a>
        <ul class="bl_simpleList02">
          <li><a href="#nameRule_general">汎用的に使用可能な名前</a></li>
          <li><a href="#nameRule_omission">単語を省略する場合</a></li>
          <li><a href="#nameRule_series">シリーズを形成する場合</a></li>
        </ul>
      </li>
      <li><a href="#base">ベース</a></li>
      <li><a href="#layout">レイアウト</a></li>
      <li>
        <a href="#block">ブロックモジュール</a>
        <ul class="bl_simpleList02">
          <li><a href="#block_applicable">適用可能なスタイル</a></li>
          <li><a href="#block_nameSize">概念・命名の粒度</a></li>
        </ul>
      </li>
      <li>
        <a href="#element">エレメントモジュール</a>
        <ul class="bl_simpleList02">
          <li><a href="#element_layout">レイアウトについて</a></li>
        </ul>
      </li>
      <li>
        <a href="#modifier">モディファイア</a>
        <ul class="bl_simpleList02">
          <li><a href="#modifier_element">エレメントモジュールの例</a></li>
          <li><a href="#modifier_block">ブロックモジュールの例</a></li>
        </ul>
      </li>
      <li>
        <a href="#helper">ヘルパー</a>
        <ul class="bl_simpleList02">
          <li><a href="#helper_clearfix">clearfixについて</a></li>
        </ul>
      </li>
      <li><a href="#unique">ユニーク</a></li>
      <li><a href="#program">プログラム</a></li>
      <li class="hp_mb30"><a href="#original">オリジナル</a></li>
      <li>
        <a href="#nestedModule">モジュールが他のモジュールにネストされる場合</a>
        <ul class="bl_simpleList02">
          <li><a href="#modifyAchild">Aモジュールの子要素に変更が生じる場合</a></li>
          <li><a href="#modifyAchild_1">Aの該当子要素モジュールに直接モディファイアを付加しスタイルを変更する</a></li>
          <li><a href="#modifyAchild_2">Aモジュールにモディファイアを付加し、ネスト指定でスタイルを変更する</a></li>
          <li><a href="#modifyAchild_3">元のAモジュールから分離した、Aモジュールの類似であるA2モジュールを作成する</a></li>
        </ul>
      </li>
      </ul>
    </div>
    <!-- /.js_stickyInner -->
  </nav>
  <!-- /.ly_stickySide -->

  <div class="bl_sectBlockCalm">
    <p class="bl_sectBlockCalm_txt">Basics</p>
  </div>
  <!-- /.bl_sectBlockCalm -->

  <div class="ly_main">
    <div class="ly_main_inner">
      <section class="bl_sectBlock">
        <h2 id="rule" class="el_ttl">記法</h2>
        <p class="el_sectTxt">
          CSSの記述方法それ自体については、基本的に<a href="https://google.github.io/styleguide/htmlcssguide.html" target="_blank">Google HTML/CSS Style Guide</a>、<a href="https://github.com/necolas/idiomatic-css" target="_blank">Principles of writing consistent, idiomatic CSS</a>に則ることを推奨します。
        </p>
      </section>
      <section class="bl_sectBlock">
        <div id="nameRule" class="bl_sectBlock">
          <h2 class="el_ttl">命名規則</h2>
          <p class="el_sectTxt">
            PRECSSでは、意図的に記述する全てのクラスに種類に応じた2文字の接頭辞を付加します。<br>
            接頭辞及び単語間はモジュールの構造に基づきスネークケースで結合し、1つの構造内に複数の単語がある場合はその部分のみキャメルケースを使用します。<br>
            基本的にIDセレクタは使用せず、全てクラスセレクタでまかないます。
          </p>
          
          
  <div class="bl_codeBlock">
    <em class="bl_codeBlock_ttl">Not recommended</em>
    <pre class="brush:html; class-name:'light'; highlight:[]">
      
            &lt;div class=&#34;bl_img_block&#34;&gt;
              &lt;div class=&#34;bl_img_block_header&#34;&gt;
                ...
              &lt;/div&gt;
              &lt;div class=&#34;bl_img_block_body&#34;&gt;
                ...
              &lt;/div&gt;
            &lt;/div&gt;
    </pre>
  </div>
  <!-- /.bl_codeBlock -->

          
          
  <div class="bl_codeBlock">
    <em class="bl_codeBlock_ttl">Recommended</em>
    <pre class="brush:html; class-name:''; highlight:[]">
      
            &lt;div class=&#34;bl_imgBlock&#34;&gt;
              &lt;div class=&#34;bl_imgBlock_header&#34;&gt;
                ...
              &lt;/div&gt;
              &lt;div class=&#34;bl_imgBlock_body&#34;&gt;
                ...
              &lt;/div&gt;
            &lt;/div&gt;
    </pre>
  </div>
  <!-- /.bl_codeBlock -->

        </div>
        <!-- /.bl_sectBlock -->

        <section id="nameRule_general" class="bl_sectBlock2">
          <h5 class="el_ttl2">汎用的に使用可能な名前</h5>
          <ul class="bl_simpleList">
            <li>_wrapper</li>
            <li>_inner</li>
            <li>_header</li>
            <li>_body</li>
            <li>_footer</li>
          </ul>
          <p class="el_sectTxt">
            これらは後述する5つのグループいずれにおいても、必要に応じて汎用的に使用することができます。<br>
            モジュール内の子要素は、モジュールのルートにあたるクラス名のみを継承するのが基本となります。<br>
            <span class="el_inlineCode">_wrapper</span>においては少しイレギュラーですが、冗長性が増すのを回避するために<span class="el_inlineCode">_wrapper</span>の子要素に「wrapper」という名前を継承させる必要はありません。
          </p>
          
          
  <div class="bl_codeBlock">
    <em class="bl_codeBlock_ttl">Not recommended</em>
    <pre class="brush:html; class-name:'light'; highlight:[]">
      
            &lt;div class=&#34;bl_imgBlock_wrapper&#34;&gt;
              &lt;div class=&#34;bl_imgBlock_wrapper_inner&#34;&gt;
                &lt;div class=&#34;bl_imgBlock_wrapper_inner_header&#34;&gt;
                  ...
                &lt;/div&gt;
              &lt;/div&gt;
            &lt;/div&gt;
    </pre>
  </div>
  <!-- /.bl_codeBlock -->

          
          
  <div class="bl_codeBlock">
    <em class="bl_codeBlock_ttl">Recommended</em>
    <pre class="brush:html; class-name:''; highlight:[]">
      
            &lt;div class=&#34;bl_imgBlock_wrapper&#34;&gt;
              &lt;div class=&#34;bl_imgBlock&#34;&gt;
                &lt;div class=&#34;bl_imgBlock_inner&#34;&gt;
                  &lt;div class=&#34;bl_imgBlock_header&#34;&gt;
                    ...
                  &lt;/div&gt;
                &lt;/div&gt;
              &lt;/div&gt;
            &lt;/div&gt;
    </pre>
  </div>
  <!-- /.bl_codeBlock -->

        </section>
        <!-- /.bl_sectBlock2 -->

        <section id="nameRule_omission" class="bl_sectBlock2">
          <h3 class="el_ttl2">単語を省略する場合</h3>
          <p class="el_sectTxt">
            CSSにおけるモジュール設計は非常に素晴らしいアイディアですが、命名が冗長になってしまうのは避けられない問題です。<br>
            PRECSSでは特に規則を設けませんが、単語を省略する場合は<a href="https://google.github.io/styleguide/htmlcssguide.html#ID_and_Class_Name_Style" target="_blank">Google HTML/CSS Style Guide</a>に基づくことを推奨します。<br>
            また2語以上で1つのまとまりを表す語群は、それぞれの頭文字の大文字のみで表現することも推奨します。ただし、ある程度一般的であったり、連続するパターンがあることが望ましいでしょう。<br>
            その他、一般的に使われる語を参考として併せて提示します。
          </p>
          <dl class="bl_definitionList">
            <dt>一般的な例</dt>
            <dd>・mainVisual→MV</dd>
          </dl>
          <dl class="bl_definitionList">
            <dt>連続するパターンの例</dt>
            <dd>・northEurope→NE</dd>
            <dd>・northAmerica→NA</dd>
            <dd>・centralSouthAmerica→CSA</dd>
          </dl>
          <dl class="bl_definitionList">
            <dt>よく使われる省略語</dt>
            <dd class="sp_ovs">
              <table class="bl_colTable hp_ML1e hp_ti0">
                <tr>
                  <th>セクション系</th>
                  <td>cat - category</td>
                  <td>col/cl - colomn</td>
                  <td>cont/conts - content(s)</td>
                  <td>lv - level</td>
                  <td>sect - section</td>
                </tr>
                <tr>
                  <th rowspan="2">単体系</th>
                  <td>btn - button</td>
                  <td>cf - clearfix</td>
                  <td>img - image</td>
                  <td>lnk - link</td>
                  <td>num - number</td>
                </tr>
                <tr>
                  <td>txt - text</td>
                  <td>ttl - title</td>
                  <td>&nbsp;</td>
                  <td>&nbsp;</td>
                  <td>&nbsp;</td>
                </tr>
                <tr>
                  <th>モディファイア</th>
                  <td>lrg - large</td>
                  <td>l - left</td>
                  <td>rev - reverse</td>
                  <td>r - right</td>
                  <td>sml - small</td>
                </tr>
              </table>
            </dd>
          </dl>
        </section>
        <!-- /.bl_sectBlock2 -->

        <section id="nameRule_series" class="bl_sectBlock2">
          <h3 class="el_ttl2">シリーズを形成する場合</h3>
           <p class="el_sectTxt">
             類似しているものはなるべく意味のある、または目的に即した命名を推奨しますが、連番を付けて管理することも許容します。ただしその場合、1つ目のものには連番を付けません。
          </p>
          
          
  <div class="bl_codeBlock">
    <em class="bl_codeBlock_ttl">Not recommended</em>
    <pre class="brush:html; class-name:'light'; highlight:[1]">
      
            &lt;div class=&#34;bl_imgBlock1&#34;&gt;...&lt;/div&gt;
            &lt;div class=&#34;bl_imgBlock2&#34;&gt;...&lt;/div&gt;
            &lt;div class=&#34;bl_imgBlock3&#34;&gt;...&lt;/div&gt;
    </pre>
  </div>
  <!-- /.bl_codeBlock -->

          
          
  <div class="bl_codeBlock">
    <em class="bl_codeBlock_ttl">Recommended</em>
    <pre class="brush:html; class-name:''; highlight:[1]">
      
            &lt;div class=&#34;bl_imgBlock&#34;&gt;...&lt;/div&gt;
            &lt;div class=&#34;bl_imgBlock2&#34;&gt;...&lt;/div&gt;
            &lt;div class=&#34;bl_imgBlock3&#34;&gt;...&lt;/div&gt;
    </pre>
  </div>
  <!-- /.bl_codeBlock -->

        </section>
        <!-- /.bl_sectBlock2 -->
      </section>
      <!-- /.bl_sectBlock -->
    </div>
    <!-- /.ly_main_inner -->
  </div>
  <!-- /.ly_main -->

<div class="bl_sectBlockCalm">
  <p class="bl_sectBlockCalm_txt">Documentation</p>
</div>
<!-- /.bl_sectBlockCalm -->

  <div class="ly_main hp_bgcLightPink">
    <div class="ly_main_inner">
      <section class="bl_sectBlock">
        <div class="bl_sectBlock">
          <h2 class="el_ttl">基本設計</h2>
          <p class="el_sectTxt">
            PRECSSは下記の6つのグループから構成されています。<br>
            <span class="el_note">※ソースコードは最低限解説に必要な記述のみを記載しています。</span>
          </p>
          <ol class="bl_simpleList">
          <li><a href="#base">ベース</a></li>
            <li><a href="#layout">レイアウト</a></li>
            <li>
              <a href="#module">モジュール</a>
              <ol class="bl_simpleList hp_mb0">
              <li><a href="#block">ブロックモジュール</a></li>
                <li><a href="#element">エレメントモジュール</a></li>
              </ol>
            </li>
            <li><a href="#helper">ヘルパー</a></li>
            <li><a href="#unique">ユニーク</a></li>
            <li><a href="#program">プログラム</a></li>
            <li><a href="#original">(オリジナル)</a></li>
          </ol>
        </div>
        <!-- /.bl_sectBlock -->

        <section id="base" class="bl_sectBlock2">
          <h3 class="el_ttl2">1.ベース</h3>
          <p class="el_sectTxt">
            <em class="el_note2">接頭辞：なし</em>
          </p>
          <p class="el_sectTxt">
            ベースはSMACSSと同じように扱います。reset.cssやnormalize.cssによる素地作りの他、サイト全体にまつわるスタイルを要素セレクタに直接指定します。<br>
            またPRECSSでは、特定のスコープ内における限定的なベーススタイルの適用も許容します。<br>
            例えば「ヘッダー内のリンクは全て白色だが、フッター内は青色に統一したい」という場合に、限定的なベーススタイルを使用します。（ただし詳細度を高める行為であるため、十分注意してください）
          </p>
          
          
  <div class="bl_codeBlock">
    <em class="bl_codeBlock_ttl">CSS</em>
    <pre class="brush:css; class-name:''; highlight:[]">
      
            .ly_header a {
              color: #fff;
            }
            .ly_footer a {
              color: blue;
            }
    </pre>
  </div>
  <!-- /.bl_codeBlock -->

        </section>
        <!-- /.bl_sectBlock2 -->

        <section id="layout" class="bl_sectBlock2">
          <h3 class="el_ttl2">2.レイアウト</h3>
          <p class="el_sectTxt">
            <em class="el_note2">接頭辞：ly_</em>
          </p>
          <p class="el_sectTxt">
            lyはlayoutの略です。ヘッダー、ボディエリア、メインエリア、サイドエリア、フッター等の大きなレイアウトを形成する要素に使用します。
          </p>
          <iframe class="el_iframe js_iframe" src="/sample/layout.html"></iframe>
          
          
  <div class="bl_codeBlock">
    <em class="bl_codeBlock_ttl">HTML</em>
    <pre class="brush:html; class-name:''; highlight:[]">
      
            &lt;header class=&#34;ly_header&#34;&gt;
              ...
            &lt;/header&gt;
            &lt;div class=&#34;ly_body&#34;&gt;
              &lt;div class=&#34;ly_main&#34;&gt;
                ...
              &lt;/div&gt;
              &lt;div class=&#34;ly_side&#34;&gt;
                ...
              &lt;/div&gt;
            &lt;/div&gt;
            &lt;footer class=&#34;ly_footer&#34;&gt;
              ...
            &lt;/footer&gt;
    </pre>
  </div>
  <!-- /.bl_codeBlock -->

          
          
  <div class="bl_codeBlock">
    <em class="bl_codeBlock_ttl">CSS</em>
    <pre class="brush:css; class-name:''; highlight:[]">
      
            .ly_header {
              background-color: #f4d9d9;
            }
            .ly_body {
              width: 100%
              max-width: 960px;
              margin: 0 auto;
              background-color: #f9ebd1;
            }
            .ly_main {
              float: left;
              width: 68%;
              background-color: #d7f5e0;
            }
            .ly_side {
              float: right;
              width: 30%;
              background-color: #ecefc9;
            }
            .ly_footer {
              background-color: #dbd9e5;
            }
    </pre>
  </div>
  <!-- /.bl_codeBlock -->

        </section>
        <!-- /.bl_sectBlock2 -->

        <section id="module" class="bl_sectBlock2">
          <h3 class="el_ttl2">3.モジュール</h3>
          <p class="el_sectTxt">
            PRECSSでは移植性の高いコードをモジュールとして管理します。
          </p>

          <section id="block" class="bl_sectBlock3">
            <h4 class="el_ttl3">3-1.ブロックモジュール</h4>
            <p class="el_sectTxt">
              <em class="el_note2">接頭辞：bl_</em>
            </p>
            <p class="el_sectTxt">
              blはblockの略です。ブロックモジュール特有の複数の子要素や、後述するエレメントモジュールを内包し、<em class="el_caution">一つの塊として持ち運び可能なモジュール群</em>を形成します。<br>
              ブロックモジュールの子要素は基本的に親の名前のみを継承し、アンダースコアの後に子要素の名前を続けます。<br>
              例えば子要素の中に子要素がネストされている際も、ネストされている子要素はあくまで親の名前のみを継承します。
            </p>
            <iframe class="el_iframe js_iframe" src="/sample/blockModule.html"></iframe>
            
            
  <div class="bl_codeBlock">
    <em class="bl_codeBlock_ttl">HTML</em>
    <pre class="brush:html; class-name:''; highlight:[]">
      
              &lt;div class=&#34;bl_sectBlock&#34;&gt;
                &lt;h2 class=&#34;bl_sectBlock_ttl&#34;&gt;.bl_sectBlock&lt;/h2&gt;
                &lt;p class=&#34;bl_sectBlock_txt&#34;&gt;
                  &lt;img class=&#34;bl_sectBlock_img&#34; src=&#34;&#34;&gt;
                  Lorem ipsum...
                &lt;/p&gt;
              &lt;/div&gt;

              &lt;div class=&#34;bl_imgBlock&#34;&gt;
                &lt;h3 class=&#34;bl_imgBlock_ttl&#34;&gt;.bl_imgBlock&lt;/h3&gt;
                &lt;p class=&#34;bl_imgBlock_img&#34;&gt;&lt;img src=&#34;&#34;&gt;&lt;/p&gt;
                &lt;p class=&#34;bl_imgBlock_txt&#34;&gt;
                  Lorem ipsum...
                &lt;/p&gt;
              &lt;/div&gt;
    </pre>
  </div>
  <!-- /.bl_codeBlock -->

            
            
  <div class="bl_codeBlock">
    <em class="bl_codeBlock_ttl">CSS</em>
    <pre class="brush:css; class-name:''; highlight:[]">
      
              .bl_sectBlock {
                padding: 1%;
                margin-bottom: 20px;
                border: 1px solid #ccc;
              }
              .bl_sectBlock_ttl {...}
              .bl_sectBlock_txt {...}
              .bl_sectBlock_img {...}

              .bl_imgBlock {
                padding: 1%;
                margin-bottom: 20px;
                border: 1px solid #ccc;
                text-align: center;
              }
              .bl_imgBlock_ttl {...}
              .bl_imgBlock_img {
                &gt; img {...}
              }
              .bl_imgBlock_txt {...}
    </pre>
  </div>
  <!-- /.bl_codeBlock -->


            <p class="el_sectTxt">
              ただし、
            </p>
            <ul class="bl_simpleList">
              <li>親子関係を意図をもって明確に定義したい</li>
              <li>モジュールが大きいため、子要素の名前の重複を避けたい</li>
            </ul>
            <p class="el_sectTxt">
              のいずれかに該当する場合は、 ネストされた子要素のクラス名に直近の子要素の名前を含めることも許容します。<br>
              次のコードは4行目で<span class="el_inlineCode">.bl_sectBlock_ttl_note</span>が<span class="el_inlineCode">.bl_sectBlock_ttl</span>の子要素であることをクラス名で明示し、また、10行目の<span class="el_inlineCode">.bl_sectBlock_note</span>との重複を避けています。
            </p>

            
            
  <div class="bl_codeBlock">
    <em class="bl_codeBlock_ttl">HTML</em>
    <pre class="brush:html; class-name:''; highlight:[4,10]">
      
              &lt;div class=&#34;bl_sectBlock&#34;&gt;
                &lt;h2 class=&#34;bl_sectBlock_ttl&#34;&gt;
                  .bl_sectBlock
                  &lt;span class=&#34;bl_sectBlock_ttl_note&#34;&gt;Note here&lt;/span&gt;
                &lt;/h2&gt;
                &lt;p class=&#34;bl_sectBlock_txt&#34;&gt;
                  &lt;img class=&#34;bl_sectBlock_img&#34; src=&#34;&#34;&gt;
                  Lorem ipsum...
                &lt;/p&gt;
                &lt;p class=&#34;bl_sectBlock_note&#34;&gt;
                 * Note here...
                &lt;/p&gt;
              &lt;/div&gt;
    </pre>
  </div>
  <!-- /.bl_codeBlock -->


            <p class="el_sectTxt">
              またPRECSSではSMACSSと同様に、子要素のタグにスタイルを直接指定することを許容します。ただしその際はなるべく子結合子で指定をすること、<span class="el_inlineCode">div</span>や<span class="el_inlineCode">span</span>等のセマンティックでない要素は独自のクラスを付加することを推奨します。<br>
              また、あまり階層が深くなり過ぎるとコードの見通しや詳細度の管理に影響が出る恐れがあるため、ネストは3階層程度までを目処とし、それ以上になりそうな場合は適宜クラスを付加することを推奨します。
            </p>
            
            
  <div class="bl_codeBlock">
    <em class="bl_codeBlock_ttl">HTML</em>
    <pre class="brush:html; class-name:''; highlight:[]">
      
                &lt;ul class=&#34;bl_circleList&#34;&gt;
                  &lt;li&gt;list 1&lt;/li&gt;
                  &lt;li&gt;list 2&lt;/li&gt;
                &lt;/ul&gt;
    </pre>
  </div>
  <!-- /.bl_codeBlock -->

            
            
  <div class="bl_codeBlock">
    <em class="bl_codeBlock_ttl">CSS</em>
    <pre class="brush:css; class-name:''; highlight:[]">
      
                .bl_circleList {
                  padding-left: 1em;
                  margin-bottom: 20px;
                }
                .bl_circleList &gt; li {
                  list-style-type: circle;
                }
    </pre>
  </div>
  <!-- /.bl_codeBlock -->


            <section id="block_applicable" class="bl_sectBlock4">
            <h5 class="el_ttl4">ブロックモジュールに適用可能なスタイル</h5>
            <p class="el_sectTxt">
              注意点として、<em class="el_caution">ブロックモジュールには他の要素に影響を及ぼさないスタイルのみを適用します</em>。<br>
              ただし例外として、デザインシステム上でモジュールの上下間の余白に統一されたルールがある場合は、<span class="el_inlineCode">margin-top/bottom</span>の適用を許容します。
            </p>
            <p class="el_sectTxt">
              他に影響を及ぼすスタイル、即ち<span class="el_inlineCode">float</span>や<span class="el_inlineCode">width</span>等のレイアウトに関わるものは、BEMと同様に上位のモジュールのElementとしてスタイルを適用することを基本とします。この例については、この後の「複数カラムの例」のコードを参考にしてください。<br>
              <em class="el_caution">即ちブロックモジュールの幅は、なるべく初期値のまま（多くはブロックレベルであるため、横いっぱいに広がる）あることが望ましく</em>、このことにより高い拡張性と移植性が実現されます。<br>
              この挙動については、カラムを持つブロックモジュールを例に考えると理解しやすいでしょう。
            </p>
              <section class="bl_sectBlock5">
                <h6 class="el_ttl5">1カラムの例</h5>
                <p class="bl_sectBlock5_txt">
                  この例ではこれが最小のブロックモジュールであり、レイアウトに関する指定をしないことで単体で使用できるほか、何処へでも移植することが可能です。
                </p>
                <iframe class="el_iframe js_iframe" src="/sample/blockModule2.html"></iframe>
                
                
  <div class="bl_codeBlock">
    <em class="bl_codeBlock_ttl">HTML</em>
    <pre class="brush:html; class-name:''; highlight:[]">
      
                  &lt;div class=&#34;bl_imgBlock&#34;&gt;
                    &lt;h3 class=&#34;bl_imgBlock_ttl&#34;&gt;bl_imgBlock&lt;/h3&gt;
                    &lt;p class=&#34;bl_imgBlock_img&#34;&gt;&lt;img src=&#34;//goo.gl/7lQK1g&#34;&gt;&lt;/p&gt;
                    &lt;p class=&#34;bl_imgBlock_txt&#34;&gt;
                      Lorem ipsum...
                    &lt;/p&gt;
                  &lt;/div&gt;
    </pre>
  </div>
  <!-- /.bl_codeBlock -->

                
                
  <div class="bl_codeBlock">
    <em class="bl_codeBlock_ttl">CSS</em>
    <pre class="brush:css; class-name:''; highlight:[]">
      
                  .bl_imgBlock {
                    margin-bottom: 20px;
                    border: 1px solid #ccc;
                    text-align: center;
                  }
                  .bl_imgBlock_ttl {
                    font-weight: bold;
                    font-size: 1em;
                  }
                  .bl_imgBlock_img {
                    &gt; img {
                      width: 100%;
                      max-width: 100px;
                    }
                  }
                  .bl_imgBlock_txt {
                    line-height: 1.2;
                  }
    </pre>
  </div>
  <!-- /.bl_codeBlock -->

              </section>
              <!-- /.bl_sectBlock5 -->

              <section class="bl_sectBlock5">
                <h6 class="el_ttl5">複数カラムの例</h5>
                <p class="bl_sectBlock5_txt">
                  <span class="el_inlineCode">bl_imgUnit</span>という要素でラップすることにより、既存のブロックモジュールに影響を与えることなく、またCSSの修正の必要もなく再利用することができます(このとき<span class="el_inlineCode">margin-top/bottom</span>にも変更が必要な場合は、併せて上書きします)。<br>
                  さらに<span class="el_inlineCode">bl_imgUnit</span>自体が高次のブロックモジュールとなったため、<em class="el_caution">今後は<span class="el_inlineCode">bl_imgUnit</span>を他に移植することも可能</em>となります。<br>
                  またwidthをカラム数に応じたモディファイアから制御することで、高い拡張性を実現します。
                </p>
                <iframe class="el_iframe js_iframe" src="/sample/blockModule3.html"></iframe>
                
                
  <div class="bl_codeBlock">
    <em class="bl_codeBlock_ttl">HTML</em>
    <pre class="brush:html; class-name:''; highlight:[1,10]">
      
                  &lt;ul class=&#34;bl_imgUnit bl_imgUnit__col2&#34;&gt;
                    &lt;li class=&#34;bl_imgUnit_item&#34;&gt;
                      &lt;div class=&#34;bl_imgBlock&#34;&gt;...&lt;/div&gt;
                    &lt;/li&gt;
                    &lt;li class=&#34;bl_imgUnit_item&#34;&gt;
                      &lt;div class=&#34;bl_imgBlock&#34;&gt;...&lt;/div&gt;
                    &lt;/li&gt;
                  &lt;/ul&gt;

                  &lt;ul class=&#34;bl_imgUnit bl_imgUnit__col3&#34;&gt;
                    &lt;li class=&#34;bl_imgUnit_item&#34;&gt;
                      &lt;div class=&#34;bl_imgBlock&#34;&gt;...&lt;/div&gt;
                    &lt;/li&gt;
                    &lt;li class=&#34;bl_imgUnit_item&#34;&gt;
                      &lt;div class=&#34;bl_imgBlock&#34;&gt;...&lt;/div&gt;
                    &lt;/li&gt;
                    &lt;li class=&#34;bl_imgUnit_item&#34;&gt;
                      &lt;div class=&#34;bl_imgBlock&#34;&gt;...&lt;/div&gt;
                    &lt;/li&gt;
                  &lt;/ul&gt;
    </pre>
  </div>
  <!-- /.bl_codeBlock -->

                
                
  <div class="bl_codeBlock">
    <em class="bl_codeBlock_ttl">CSS</em>
    <pre class="brush:css; class-name:''; highlight:[]">
      
                  .bl_imgUnit {
                    padding: 1%;
                    margin-bottom: 20px;
                    border: 1px solid #ccc;
                    box-sizing: border-box;
                    text-align: center;
                  }
                  .bl_imgUnit_item {
                    display: inline-block;
                    margin: 0 2% 0 0;
                  }
                  .bl_imgUnit_item:last-child {
                    margin-right: 0;
                  }
                  .bl_imgUnit__col2 .bl_imgUnit_item {
                    width: 47%;
                  }
                  .bl_imgUnit__col3 .bl_imgUnit_item {
                    width: 30%;
                  }
    </pre>
  </div>
  <!-- /.bl_codeBlock -->

              </section>
              <!-- /.bl_sectBlock5 -->
              <p class="bl_sectBlock5_txt">
                極端な例を示すと、これらをメインエリア・サイドエリアそれぞれに移植するとこのような形になります。
              </p>
              <iframe class="el_iframe js_iframe" src="/sample/blockModule4.html"></iframe>
            </section>
            <!-- /.bl_sectBlock4 -->

            <p class="el_sectTxt">
              以上のようにブロックモジュールというのは非常に柔軟で、パワフルにコード内を駆け回ることができます。
            </p>
            <p class="el_sectTxt">
              今回の例では<span class="el_inlineCode">.bl_imgUnit</span>という専用の高次モジュールを作成しましたが、「ブロックモジュールのwidthは初期値のままにしておく」ということを遵守していれば、他のCSSフレームワークが提供するグリッドシステムと連携することも可能です。<br>
              ただし、その高い移植性を維持するためには「レイアウトに関するスタイルは高次モジュールから制御する」という少し特殊なテクニックが必要で、慣れないうちは苦労するでしょう。<br>
              さらに複雑なブロックモジュールの移植については、下部に<a href="#nestedModule">Advance Case</a>としてまとめたので、そちらをご参照ください。
            </p>
            <p class="el_sectTxt">
              また下記に、ブロックモジュールを命名する際に役立つ粒度の指針を提供します。<br>PRECSSにおいてブロックモジュールは非常に重要な役割を担うため、これらの語を省略することは推奨しません。<br>
              必ずしもこれらの名前を含まなければならない訳ではありませんが、これらを参考にすることは、あなたがブロックモジュールを自在に操ることを強力に手助けしてくれるでしょう（現実として、Unit以上の大きさを使用することはあまり無いでしょう）。
            </p>

            <section id="block_nameSize" class="bl_sectBlock4">
              <h5 class="el_ttl4">ブロックモジュールにおける概念・命名の粒度</h5>
              <ul class="bl_simpleList">
                <li>Block - ブロックモジュールの基本単位。そのモジュール特有の複数の子要素や、エレメントモジュールを含む</li>
                <li>Unit - Blockの集まり</li>
                <li>Box - Unitの集まり</li>
                <li>Container - Boxの集まり</li>
              </ul>
            </section>
            <!-- /.bl_sectBlock4 -->
          </section>
          <!-- /.bl_sectBlock3 -->

          <section id="element" class="bl_sectBlock3">
            <h4 class="el_ttl3">3-2.エレメントモジュール</h4>
            <p class="el_sectTxt">
              <em class="el_note2">接頭辞：el_</em>
            </p>
            <p class="el_sectTxt">
              elはelementの略です。ボタンやラベル、見出し等の最小単位のモジュールで、単体で持ち運ぶことが可能です。<br>
              命名は<em class="el_caution">極力汎用的なもの</em>を推奨します。これはどのようなものがコンテンツとして入ったとしても、名前と内容が乖離しないための措置です。<br>
              「極力汎用的な命名を」というのはBEMとは真逆の方向を向いている思想ですが、現実として、例えば全ての色に意味を持たせた命名は困難です。
              <span class="el_note">※もちろんプロジェクトのデザインシステムにおいて、スタイルと命名がセマンティックに一致する場合は、その限りではありません（色がきちんとテーマカラーとして定義されていたり、商品やブランドがテーマカラーを持つ場合など）。</span>
            </p>
            <p class="el_sectTxt">
              類似するスタイルのエレメントモジュールが複数存在する場合は、OOCSSにおけるストラクチャとスキンの考え方を使用します。<br>
              個別のスキンは後述するモディファイアで実装します。
            </p>

            <iframe class="el_iframe js_iframe" src="/sample/elementModule.html"></iframe>
            
            
  <div class="bl_codeBlock">
    <em class="bl_codeBlock_ttl">Not recommended(HTML)</em>
    <pre class="brush:html; class-name:'light'; highlight:[4,5,12,13]">
      
              &lt;div class=&#34;bl_sectBlock&#34;&gt;
                &lt;h2 class=&#34;bl_sectBlock_ttl&#34;&gt;.bl_sectBlock
                  &lt;!-- 名前が汎用的でないため推奨しない --&gt;
                  &lt;span class=&#34;el_label el_label__news&#34;&gt;News&lt;/span&gt;
                  &lt;span class=&#34;el_label el_label__blog&#34;&gt;Blog&lt;/span&gt;
                &lt;/h2&gt;
                ...
              &lt;/div&gt;

              &lt;p class=&#34;hp_tac&#34;&gt;
                &lt;!-- 名前が汎用的でないため推奨しない --&gt;
                &lt;button href=&#34;&#34; class=&#34;el_btn el_btn__cancel&#34;&gt;Cancel&lt;/button&gt;
                &lt;button href=&#34;&#34; class=&#34;el_btn el_btn__submit&#34;&gt;Submit&lt;/button&gt;
              &lt;/p&gt;
    </pre>
  </div>
  <!-- /.bl_codeBlock -->

            
            
  <div class="bl_codeBlock">
    <em class="bl_codeBlock_ttl">Recommended(HTML)</em>
    <pre class="brush:html; class-name:''; highlight:[3,4,10,11]">
      
              &lt;div class=&#34;bl_sectBlock&#34;&gt;
                &lt;h2 class=&#34;bl_sectBlock_ttl&#34;&gt;.bl_sectBlock
                  &lt;span class=&#34;el_label el_label__red&#34;&gt;News&lt;/span&gt;
                  &lt;span class=&#34;el_label el_label__blue&#34;&gt;Blog&lt;/span&gt;
                &lt;/h2&gt;
                ...
              &lt;/div&gt;

              &lt;p class=&#34;hp_tac&#34;&gt;
                &lt;button href=&#34;&#34; class=&#34;el_btn el_btn__blue&#34;&gt;Cancel&lt;/button&gt;
                &lt;button href=&#34;&#34; class=&#34;el_btn el_btn__orange&#34;&gt;Submit&lt;/button&gt;
              &lt;/p&gt;
    </pre>
  </div>
  <!-- /.bl_codeBlock -->

            
            
  <div class="bl_codeBlock">
    <em class="bl_codeBlock_ttl">Recommended(CSS)</em>
    <pre class="brush:css; class-name:''; highlight:[]">
      
              .el_label {
                display: inline-block;
                padding: .2em .5em;
                color: #fff;
                &amp;.el_label__red {
                  background-color: #de5b5b;
                }
                &amp;.el_label__blue {
                  background-color: #308EDE;
                }
              }

              .el_btn {
                display: inline-block;
                max-width: 200px;
                padding: .5em 1em;
                margin-bottom: 20px;
                border-radius: 5px;
                color: #fff;
                text-align: center;
                &amp;.el_btn__orange {
                  background-color: #E18700;
                  box-shadow: 0 3px 0 #B85F29;
                }
                &amp;.el_btn__blue {
                  background-color: #308EDE;
                  box-shadow: 0 3px 0 #2572B1;
                }
              }

              .hp_tac {
                text-align: center !important;
              }
    </pre>
  </div>
  <!-- /.bl_codeBlock -->


            <section id="element_layout" class="bl_sectBlock4">
            <h5 class="el_ttl4">レイアウトについて</h5>
              <p class="el_sectTxt">
                移植性の維持のため、ブロックモジュールと同じく<em class="el_caution">エレメントモジュール自体にレイアウトのためのスタイルを当てることは推奨しません</em>。<br>
                移植先のモジュールからのElementとしての指定か、もしくは上記の<span class="el_inlineCode">.hp_tac</span>のように何らかの親要素を使用するのが理想です。（<span class="el_inlineCode">.hp_</span>については次のヘルパーセクションで解説します）
              </p>
              <p class="el_sectTxt">
                ただし、ブロックモジュールに比べエレメントモジュールはサイト全体でバリエーションに限りがあることが多いため、widthの直接指定、及びモディファイアでサイズのパターンを作成することは十分許容します（例えば、ボタンのサイズは多くのデザインにおいてパターンがあるでしょう）。
              </p>
              <p class="el_sectTxt">
                ただし、例えば
              </p>
              <ul class="bl_simpleList">
                <li>レスポンシブ・ウェブデザインを採用し</li>
                <li>スマートフォンを想定するビューでは、ボタンを横幅100%にする</li>
              </ul>
              <p class="el_sectTxt">
                となった際に、モディファイアの名前を<span class="el_inlineCode">__w250(px)</span>と数値を固定すると、<span class="el_inlineCode">__w250(px)</span>と付いているのにSPビューでの実際の表示は横幅100％という事態が発生します。
                このように名前と実際の大きさに矛盾が発生すると<em class="el_caution">破綻への第一歩</em>となることは留意しておいてください。<br>
                状況にもよりますが、解決策としては
              </p>
              <ul class="bl_simpleList">
                <li>サイズを指定する場合は、モディファイア名は<span class="el_inlineCode">__small</span>・<span class="el_inlineCode">__medium</span>・<span class="el_inlineCode">__large</span>などとする</li>
                <li>サイズを指定せずコンテンツに応じて可変にする場合は、<span class="el_inlineCode">display: inline-block;</span>としておく</li>
              </ul>
              <p class="el_sectTxt">
                などすると、応用が効くでしょう。
              </p>
              <p class="el_sectTxt">
                もしくは移植先のモジュールのElementとしての指定か、それが難しい場合は移植先のモジュールの名前と子（孫）結合子を使用したスタイリングも、あまり推奨はしませんが許容します。<br>
                次のコードは移植先のモジュールの名前と子結合子で制御した例と、モディファイアで制御した例です。
              </p>
              <iframe class="el_iframe js_iframe" src="/sample/elementModule2.html"></iframe>
              
              
  <div class="bl_codeBlock">
    <em class="bl_codeBlock_ttl">Recommended(HTML)</em>
    <pre class="brush:html; class-name:''; highlight:[]">
      
                &lt;header class=&#34;ly_header cf&#34;&gt;
                  &lt;!-- 子結合子で制御した例 --&gt;
                  &lt;a href=&#34;&#34; class=&#34;el_btn el_btn__orange&#34;&gt;.el_btn__orange&lt;br&gt;(nested)&lt;/a&gt;
                &lt;/header&gt;

                &lt;div class=&#34;ly_main&#34;&gt;
                  &lt;!-- モディファイアで制御した例 --&gt;
                  &lt;a href=&#34;&#34; class=&#34;el_btn el_btn__large el_btn__orange&#34;&gt;.el_btn__large&lt;/a&gt;
                &lt;/div&gt;
    </pre>
  </div>
  <!-- /.bl_codeBlock -->


              
              
  <div class="bl_codeBlock">
    <em class="bl_codeBlock_ttl">Recommended(CSS)</em>
    <pre class="brush:css; class-name:''; highlight:[]">
      
                // 子結合子で制御した例
                .ly_header &gt; .el_btn{
                  float: right;
                  margin: 0 20px 0 0;
                }

                .el_btn {
                  //モディファイアで制御した例
                  &amp;.el_btn__large{
                    width: 400px;
                    max-width: 400px;
                    padding-top: 1em;
                    padding-bottom: 1em;
                    @media screen and (max-width: 768px){
                      width: 100%;
                    }
                  }
                }
    </pre>
  </div>
  <!-- /.bl_codeBlock -->

            </section>
            <!-- /.bl_sectBlock4 -->
          </section>
          <!-- /.bl_sectBlock3 -->

          <section id="modifier" class="bl_sectBlock3">
            <h4 class="el_ttl3">3-3.モディファイア</h4>
            <p class="el_sectTxt">
              <em class="el_note2">命名規則：基となるクラス名__モディファイア名</em><br>
              既に何度か言及していますが、
            </p>
            <ul class="bl_simpleList">
              <li>あしらいが変わる</li>
              <li>大きさが変わる</li>
              <li>一定の規則に従って振る舞いが変わる（カラム等）</li>
            </ul>
            <p class="el_sectTxt">
              などの場合はモディファイアによる上書きをPRECSSでは推奨し、アンダースコア2つの後にモディファイア名を付与します。<br>
              「何をするモディファイアなのか」を明確にするために、モディファイア名は「<span class="el_inlineCode">__backgroundColorOrange</span>」のように「<span class="el_inlineCode">__keyValue</span>」の形を基本としますが、次の例のコードのようにおおよそ想像がつくものであればkeyの省略が可能です。<br>
              また名前が長くなるのを避けたい場合は、Emmetのショートハンドに準じて「<span class="el_inlineCode">__backgroundColorOrange</span>」を「<span class="el_inlineCode">__bgcOrange</span>」のように省略することも可能です。
            </p>
            <p class="el_sectTxt">
              多くはモジュールグループにおいて使用されますが、状況によってはレイアウトグループ等に使用することもできます。<br>
              注意点としてモディファイアでスタイルを上書きする際は、<em class="el_caution">基本的に複数クラスを使用して、詳細度を高めることを推奨しています。</em><br>
              「スタイルを上書きする」ということは意図的なアクションであり、であればCSSの読み込み順でスタイルに変化が出てしまうのは好ましくありません。
            </p>
            <p class="el_sectTxt">
              これもBEMとは異なる思想ですが、「CSSが自分の手を離れても、CSSのルールセットの順番が変わることは絶対ない」と言い切ることは私にはできません。<br>
              そのためweb開発者の都合を優先するのではなく、あくまで「スタイルを上書きする」という目的に立ち返り、想定外の事態が発生してもなるべくサイトが壊れないことを優先し、このようなルールとしています。
            </p>
            <p class="el_sectTxt">
              また「状態」を変更する際にももちろんモディファイアを使用することができますが、基本的には後述するプログラムグループで変更を制御することをPRECSSでは推奨しています。
            </p>
            <section id="modifier_element" class="bl_sectBlock4"><h5 class="el_ttl4">エレメントモジュールの例</h5>
              
              
  <div class="bl_codeBlock">
    <em class="bl_codeBlock_ttl">Not recommended</em>
    <pre class="brush:css; class-name:'light'; highlight:[]">
      
                  .el_btn__orange {
                    background-color: orange;
                  }
                  .el_btn {
                    background-color: white;
                  }
                  //適用されるカラー：white
                  //何らかの都合でスタイルの読み込み順が変わったとき、モディファイアが機能しなくなってしまう
    </pre>
  </div>
  <!-- /.bl_codeBlock -->

              
              
  <div class="bl_codeBlock">
    <em class="bl_codeBlock_ttl">Recommended</em>
    <pre class="brush:css; class-name:''; highlight:[]">
      
                  .el_btn {
                    background-color: white;
                  }
                  .el_btn.el_btn__orange {
                    background-color: orange;
                  }
    </pre>
  </div>
  <!-- /.bl_codeBlock -->

            </section>
            <!-- /.bl_sectBlock4 -->

            <section id="modifier_block" class="bl_sectBlock4">
              <h5 class="el_ttl4">ブロックモジュールの例</h5>
              <p class="el_sectTxt">
                ブロックモジュールにおいて子要素にモディファイアによる変更を適用する際、
              </p>
              <ul class="bl_simpleList">
                <li>対象の子要素のみにモディファイアを適用する</li>
                <li>ブロックモジュールのルート要素にモディファイアを適用する</li>
              </ul>
              <p class="el_sectTxt">
                の2通りの方法があげられます。<br>
                前者の場合はセオリー通り複数クラス指定をすることにより、後者の場合はモディファイア名と子（孫）結合子を使用することにより、詳細度を高めます。<br>
                後者の方法はルート要素に付与した1つのモディファイアで、複数の子要素のスタイルを変更したい場合に最適です。
              </p>
              <iframe class="el_iframe js_iframe" src="/sample/modifier.html"></iframe>
              
              
  <div class="bl_codeBlock">
    <em class="bl_codeBlock_ttl">HTML</em>
    <pre class="brush:html; class-name:''; highlight:[11,12,17,18]">
      
                &lt;div class=&#34;bl_sectBlock&#34;&gt;
                  &lt;h2 class=&#34;bl_sectBlock_ttl&#34;&gt;.bl_sectBlock&lt;/h2&gt;

                  &lt;p class=&#34;bl_sectBlock_txt cf&#34;&gt;
                    &lt;!-- 元のモジュール --&gt;
                    &lt;img class=&#34;bl_sectBlock_img&#34;&gt;
                    Lorem ipsum...
                  &lt;/p&gt;

                  &lt;p class=&#34;bl_sectBlock_txt cf&#34;&gt;
                    &lt;!-- 対象の子要素のみにモディファイアを適用する場合 --&gt;
                    &lt;img class=&#34;bl_sectBlock_img bl_sectBlock_img__rev&#34;&gt;
                    Lorem ipsum...
                  &lt;/p&gt;
                &lt;/div&gt;

                &lt;!-- 子要素複数に対してスタイルを上書きする例 --&gt;
                &lt;div class=&#34;bl_sectBlock bl_sectBlock__small&#34;&gt;
                  &lt;h3 class=&#34;bl_sectBlock_ttl&#34;&gt;.bl_sectBlock__small&lt;/h3&gt;
                  &lt;p class=&#34;bl_sectBlock_txt cf&#34;&gt;
                    &lt;img class=&#34;bl_sectBlock_img&#34;&gt;
                    Lorem ipsum...
                  &lt;/p&gt;
                &lt;/div&gt;
    </pre>
  </div>
  <!-- /.bl_codeBlock -->

              
              
  <div class="bl_codeBlock">
    <em class="bl_codeBlock_ttl">CSS</em>
    <pre class="brush:css; class-name:''; highlight:[]">
      
                // 通常のスタイル
                .bl_sectBlock_img {
                  float: left;
                  margin: 0 10px 10px 0;
                }

                // 対象の子要素のみにモディファイアを適用する場合
                .bl_sectBlock_img.bl_sectBlock_img__rev {
                  float: right;
                  margin: 0 0 10px 10px;
                }


                // 通常のスタイル
                .bl_sectBlock_ttl {
                  font-size: 1.1em;
                }
                .bl_sectBlock_txt {
                  margin-bottom: 20px;
                }
                .bl_sectBlock_img {
                  float: left;
                  margin: 0 10px 10px 0;
                }

                // 子要素複数に対してスタイルを上書きする例
                .bl_sectBlock__small .bl_sectBlock_ttl {
                  font-size: .8em;
                }
                .bl_sectBlock__small .bl_sectBlock_txt {
                  font-size: .5em;
                }
                .bl_sectBlock__small .bl_sectBlock_img {
                  width: 5%;
                }
    </pre>
  </div>
  <!-- /.bl_codeBlock -->

              <p class="el_sectTxt">
                繰り返しになりますが、ブロックモジュールそれ自体の大きさの変化に対して、モディファイアを付加することはあまり推奨しません。なぜなら大きさを固定にしてしまった場合、「その大きさが入るのか」というのは移植先のコンテキストに左右され、ブロックモジュールはエレメントモジュールに比べバリエーションが不定になりがちだからです。<br>
                ブロックモジュールは大きめに使われることが多いので、レスポンシブ時の破綻のリスクも、エレメントモジュールに比べ当然高いです。<br>
                ブロックモジュールが他所のモジュール内にネストされる場合は、モディファイアではなくネスト先のモジュールの子要素（BEMでいうElement）をセレクタとしてスタイリングすることを推奨します。（詳しくは<a href="#advance">Advance Case</a>にて解説しています）<br>
              </p>
            </section>
            <!-- /.bl_sectBlock4 -->
          </section>
          <!-- /.bl_sectBlock3 -->
        </section>
        <!-- /.bl_sectBlock2 -->

        <section id="helper" class="bl_sectBlock2">
          <h3 class="el_ttl2">4.ヘルパー</h3>
          <p class="el_sectTxt">
            <em class="el_note2">接頭辞：hp_</em>
          </p>
          <p class="el_sectTxt">
            hpはhelperの略です。基本的に1つのスタイルのみで、意図的な上書きのため<span class="el_inlineCode">!important</span>を付加します。命名規則に関しては、<a href="http://docs.emmet.io/cheat-sheet/" target="_blank">Emmetのチートシート</a>に準ずることを推奨し、その他の規則として
          </p>
          <ul class="bl_simpleList">
            <li>px以外の単位の場合は分かりやすい頭文字で表現</li>
            <li>小数点はアンダースコアで表現</li>
            <li>ネガティブな値はショートハンドを大文字で表現</li>
            <li>ショートハンドの後に文字列が続く場合はキャメルケースで表現</li>
          </ul>
          <p class="el_sectTxt">
            とします（これらの規則はモディファイアの命名にも概ね有効です）。<br>
            ただし1つの要素に対しヘルパーを多用し過ぎると、style属性を使用していることと変わりが無くなってしまうので、<em class="el_caution">ヘルパーが3つ以上になった場合はモジュール化を検討するべきでしょう</em>。
          </p>
          <p class="el_sectTxt">
            基本的に1スタイルのみのため、<span class="el_inlineCode">outputStyle:compact</span>を許容します。
            また挙動が限定的でかつ明確な場合のみ、1つ以上のスタイルであってもヘルパーで処理することが可能です。
          </p>
          
          
  <div class="bl_codeBlock">
    <em class="bl_codeBlock_ttl">CSS</em>
    <pre class="brush:css; class-name:''; highlight:[]">
      
              .hp_db { display: block !important; }
              .hp_tac { text-align: center !important; }
              .hp_w400 { width: 400px !important; }
              .hp_w50p { width: 50% !important; }
              .hp_lh1_5 { line-height: 1.5 !important; }
              .hp_MT1e { margin-top: -1em !important; }
              .hp_bgcWhite { background-color: #fff !important; }

              //1つ以上のスタイルの例
              .hp_centering {
                display: block !important;
                margin-left: auto !important;
                margin-right: auto !important;
              }
    </pre>
  </div>
  <!-- /.bl_codeBlock -->

          <section id="helper_clearfix" class="bl_sectBlock3">
            <h5 class="el_ttl3">clearfixについて</h5>
            <p class="el_sectTxt">
              PRECSSではfloatの解除にclearfixを推奨します。これは、floatの解除のためだけに本来の目的とは関係の無いスタイルを記述することを忌避するためです。<br>
              特にoverflowは本来の目的で使われる場合もあり、CSSコードだけ見たときに、それがfloatの解除のためなのか、本来の目的のためなのかわからない、といった状況は好ましくありません。<br>
              またPRECSSのルールに当てはめればclearfixもヘルパーとして定義することが可能ですが、clearfixはそれ自体が充分に一般的であるため、接頭辞を付ける必要はありません。
            </p>
          </section>
          <!-- /.bl_sectBlock3 -->
        </section>
        <!-- /.bl_sectBlock2 -->

        <section id="unique" class="bl_sectBlock2">
          <h3 class="el_ttl2">5.ユニーク</h3>
          <p class="el_sectTxt">
            ある1ページでしか使用されていないことを明示するグループです。<br>
            そのページでしか使われていないため、改修や運用の際に影響範囲を気にせずにスタイルを編集してよい目印になっています。<br>
            モジュールの大きさも自由です。小さくても大きくてもかまいせん。
          </p>
          <p class="el_sectTxt">
            例えば<a href="/" target="_blank">PRECSSの扉ページ</a>のような特別なページに使用するのもいいですし、通常のページ内でもモジュール設計から外れる場所に使用するのもいいでしょう。<br>
            つまりユニークグループは、あらゆるイレギュラーのための万能な回避策です。<br>
            何か迷ったら、とりあえずユニークグループを使ってください。いつでも誰でも、すぐに手直ししてよい目印です。<br>
            ただし濫用し過ぎると拡張性に欠けるため、あくまでイレギュラーのための措置であることを覚えておいてください。
          </p>
          <p class="el_sectTxt">
            またCSSには、どのページで使用しているかコメントを残しておくとよりよいでしょう。
          </p>
          <p class="el_sectTxt">
            <em class="el_note2">接頭辞：un_</em>
          </p>
          
  <div class="bl_codeBlock">
    <em class="bl_codeBlock_ttl">HTML</em>
    <pre class="brush:html; class-name:''; highlight:[]">
      
              &lt;div class=&#34;un_siteRoot_wrapper&#34;&gt;
                &lt;section class=&#34;un_siteRoot&#34;&gt;
                  &lt;p class=&#34;un_siteRoot_logo&#34;&gt;&lt;img src=&#34;images/icon.svg&#34; alt=&#34;PRECSS logo&#34;&gt;&lt;/p&gt;
                  &lt;h1 class=&#34;un_siteRoot_ttl&#34;&gt;PRECSS&lt;/h1&gt;
                  &lt;p class=&#34;un_siteRoot_link&#34;&gt;&lt;span class=&#34;is_deactive&#34;&gt;English&lt;/span&gt; / &lt;a href=&#34;/ja/&#34;&gt;日本語&lt;/a&gt;&lt;/p&gt;
                &lt;/section&gt;
              &lt;/div&gt;
    </pre>
  </div>
  <!-- /.bl_codeBlock -->

          
          
  <div class="bl_codeBlock">
    <em class="bl_codeBlock_ttl">Recommended(CSS)</em>
    <pre class="brush:css; class-name:''; highlight:[]">
      
              //トップページに使用
              .un_siteRoot_wrapper {
                position: relative;
                top: 33vh;
                text-align: center;
              }
              .un_siteRoot {
                display: inline-block;
              }...
    </pre>
  </div>
  <!-- /.bl_codeBlock -->

        </section>
        <!-- /.bl_sectBlock2 -->

        <section id="program" class="bl_sectBlock2">
          <h3 class="el_ttl2">6.プログラム</h3>
          <p class="el_sectTxt">
            PRECSSではJavaScript等のプログラムで要素にタッチする際、極力専用のクラスを付加しCSS用のクラスとは分離することを推奨します。
          </p>
          <p class="el_sectTxt">
            <em class="el_note2">接頭辞：js_</em>
          </p>
          <p class="el_sectTxt">
            JavaScriptにて要素を取得するためのクラスです。
          </p>
          <p class="el_sectTxt">
            <em class="el_note2">接頭辞：is_</em>
          </p>
          <p class="el_sectTxt">
            要素の状態を管理するためのクラスです。上書きはモディファイアの場合と同じく複数クラスで行う他、必ず適用されなければならないスタイルであるため、<span class="el_inlineCode">!important</span>の使用も許容します。<br>
            状態の命名は<span class="el_inlineCode">is_active</span>とシンプルに記述することが可能ですが、他の箇所にも影響を及ぼさないよう<em class="el_caution">必ず複数クラスでスタイルを適用</em>する必要があります。<br>
            <span class="el_note">※対応ブラウザや状況によっては、JavaScript用のクラスではなく、カスタムデータ属性を付加することも推奨します。</span>
          </p>
          
  <div class="bl_codeBlock">
    <em class="bl_codeBlock_ttl">HTML</em>
    <pre class="brush:html; class-name:''; highlight:[]">
      
              &lt;div class=&#34;bl_sectBlock js_accordion&#34;&gt;
                &lt;h3 class=&#34;bl_sectBlock_ttl js_accordion_head&#34;&gt;Title Here&lt;/h3&gt;
                &lt;p class=&#34;bl_sectBlock_txt js_accordion_body is_active&#34;&gt;
                  Lorem ipsum...
                &lt;/p&gt;
              &lt;/div&gt;
    </pre>
  </div>
  <!-- /.bl_codeBlock -->

          
          
  <div class="bl_codeBlock">
    <em class="bl_codeBlock_ttl">Not recommended(CSS)</em>
    <pre class="brush:css; class-name:'light'; highlight:[5]">
      
              .js_accordion_body {
                display: none;
              }
              //他の箇所にまで影響を及ぼす可能性がある
              .is_active {
                display: block;
              }
    </pre>
  </div>
  <!-- /.bl_codeBlock -->

          
          
  <div class="bl_codeBlock">
    <em class="bl_codeBlock_ttl">Recommended(CSS)</em>
    <pre class="brush:css; class-name:''; highlight:[4]">
      
              .js_accordion_body {
                display: none;
              }
              .js_accordion_body.is_active {
                display: block;
              }
    </pre>
  </div>
  <!-- /.bl_codeBlock -->

        </section>
        <!-- /.bl_sectBlock2 -->

        <section id="original" class="bl_sectBlock2">
          <h3 class="el_ttl2">7.オリジナル</h3>
          <p class="el_sectTxt">
            その他、サイトの構築思想に応じて柔軟に接頭辞を追加できるのがPRECSSの特徴です。 <br>例えばオリジナルのグリッドレイアウトを構築する場合、gridの略として<span class="el_inlineCode">.gr_4</span>、<span class="el_inlineCode">gr_6</span>やcolumnの略として<span class="el_inlineCode">.cl_4</span>、<span class="el_inlineCode">cl_6</span>といった接頭辞を追加することができます。<br>
            スマートフォンのみ有効なクラスは<span class="el_inlineCode">.sp_**</span>、タブレットのみ有効なクラスは<span class="el_inlineCode">.tb_**</span>とするのもいいでしょう。<br>
            一定の法則に従っている限り、PRECSSはどんなものでも臆することなく受け入れます。
          </p>
        </section>
        <!-- /.bl_sectBlock2 -->
      </section>
      <!-- /.bl_sectBlock -->
    </div>
    <!-- /.ly_main_inner -->
  </div>
  <!-- /.ly_main -->

  <div class="bl_sectBlockCalm">
    <p class="bl_sectBlockCalm_txt">Advance Case</p>
  </div>
  <!-- /.bl_sectBlockCalm -->

  <div class="ly_main">
    <div class="ly_main_inner">
      <section id="nestedModule" class="bl_sectBlock">
        <h2 class="el_ttl">モジュールが他のモジュールにネストされる場合</h2>
        <p class="el_sectTxt">
          PRECSSでは一つのブロックモジュール内に他のブロックモジュール、またはエレメントモジュールがネストされることがあります。これは、モジュールが「持ち運び可能なもの」である思想の下の挙動です。<br>
          その際に直面する、主にレイアウトの問題について、幾つか指針を示します。<br>
          現在構築中のモジュールをA、既に他所で構築済みで、Aに移植したいモジュールをBとしましょう。<br>
          基本的な原則は、以下の2つのみです。
        </p>
        <ul class="bl_simpleList">
          <li>Bのレイアウトは、Aからのネストで制御する<br>
          (子セレクタ指定が好ましいですが、状況により子孫セレクタも許容します)</li>
          <li>B内の子要素は、Aからのネストで制御してはならない</li>
        </ul>
        <iframe class="el_iframe js_iframe" src="/sample/advance.html"></iframe>
        
        
  <div class="bl_codeBlock">
    <em class="bl_codeBlock_ttl">HTML</em>
    <pre class="brush:html; class-name:''; highlight:[16,17,18,19]">
      
          &lt;div class=&#34;ly_side&#34;&gt;
            &lt;!-- Bモジュール --&gt;
            &lt;div class=&#34;bl_imgBlock&#34;&gt;
              &lt;h3 class=&#34;bl_imgBlock_ttl&#34;&gt;.bl_imgBlock&lt;/h3&gt;
              &lt;p class=&#34;bl_imgBlock_img&#34;&gt;&lt;img src=&#34;//goo.gl/15naui&#34;&gt;&lt;/p&gt;
              &lt;p class=&#34;bl_imgBlock_txt&#34;&gt;
                Lorem ipsum...
              &lt;/p&gt;
            &lt;/div&gt;
          &lt;/div&gt;

          &lt;div class=&#34;ly_main&#34;&gt;
            &lt;!-- Aモジュール --&gt;
            &lt;div class=&#34;bl_sectBlock cf&#34;&gt;
              &lt;h2 class=&#34;bl_sectBlock_ttl&#34;&gt;.bl_sectBlock&lt;/h2&gt;
              &lt;!-- Bモジュールの移植 --&gt;
              &lt;div class=&#34;bl_imgBlock&#34;&gt;
                ...
              &lt;/div&gt;
              &lt;p class=&#34;bl_sectBlock_txt&#34;&gt;
                Lorem ipsum...
              &lt;/p&gt;
            &lt;/div&gt;
          &lt;/div&gt;
    </pre>
  </div>
  <!-- /.bl_codeBlock -->

        
        
  <div class="bl_codeBlock">
    <em class="bl_codeBlock_ttl">CSS</em>
    <pre class="brush:css; class-name:''; highlight:[]">
      
          //Bモジュール
          .bl_imgBlock{
            margin: 0 0 20px 0;
          }

          //BモジュールをAモジュールに移植
          .bl_sectBlock{
            &gt; .bl_imgBlock{
              width: 25%;
              float: left;
              margin: 0 10px 10px 0;
            }
          }
    </pre>
  </div>
  <!-- /.bl_codeBlock -->


        <p class="el_sectTxt">
          2つ目の「B内の子要素は、Aからのネストで制御してはならない」について、もう詳しく解説します。
        </p>
        <p class="el_sectTxt">
          BをAに移植した際にBの子要素に何らかの変更が必要な場合、<span class="el_inlineCode">A > B > 子要素</span>という形でスタイルを上書きしてはいけません。<br>
          これはモジュールブロックそれ自体が、<em class="el_caution">単独で完結する1つの塊</em>という思想であるからです。塊それ自体のレイアウトは移植先モジュールのコンテキストにより挙動を変えるのは可能ですが、その子要素までもがコンテキストに影響されるのは好ましくありません。<br>
          誤解を恐れずに言えば、AモジュールからBモジュールそれ自体は制御可能だが、Bモジュールの内部については隠蔽されるべき、という感覚です。<br>
          ブロックモジュール内の変更はあくまで、そのブロックモジュール内で完結すべきということから、<em class="el_caution">ブロックモジュール内はそのブロックモジュール以外からの変更を受けない聖域</em>となっています。
        </p>
        <p class="el_sectTxt">
          現実としてAモジュールへ組み込みの際にBモジュール内に変更が必要な場合は、Bモジュールにモディファイアを付加することで処理します。<br>
          ここでは、BモジュールがAモジュールに移植された際に、コンテンツが全体的に小さくなる例を示します。
        </p>
        <iframe class="el_iframe js_iframe" src="/sample/advance2.html"></iframe>
        
        
  <div class="bl_codeBlock">
    <em class="bl_codeBlock_ttl">HTML</em>
    <pre class="brush:html; class-name:''; highlight:[5,6,7,8]">
      
          &lt;div class=&#34;ly_main&#34;&gt;
            &lt;!-- Aモジュール --&gt;
            &lt;div class=&#34;bl_sectBlock cf&#34;&gt;
              &lt;h2 class=&#34;bl_sectBlock_ttl&#34;&gt;.bl_sectBlock&lt;/h2&gt;
              &lt;!-- Bモジュールの移植、bl_imgBlock__smlモディファイアの付加 --&gt;
              &lt;div class=&#34;bl_imgBlock bl_imgBlock__sml&#34;&gt;
                ...
              &lt;/div&gt;
              &lt;p class=&#34;bl_sectBlock_txt&#34;&gt;
                Lorem ipsum...
              &lt;/p&gt;
            &lt;/div&gt;
          &lt;/div&gt;
    </pre>
  </div>
  <!-- /.bl_codeBlock -->

        
        
  <div class="bl_codeBlock">
    <em class="bl_codeBlock_ttl">CSS</em>
    <pre class="brush:css; class-name:''; highlight:[]">
      
          //Bモジュールにbl_imgBlock__smlモディファイアの付加
          .bl_imgBlock{
            &amp;.bl_imgBlock__sml{
              &gt; .bl_imgBlock_ttl{
                margin: 0 0 5px 0;
                font-size: .8em;
              }
              &gt; .bl_imgBlock_img{
                margin: 0 0 5px 0;
                &gt; img{
                  max-width: 80px;
                }
              }
              .bl_imgBlock_txt{
                margin: 0 0 10px 0;
                font-size: .8em;
              }
            }
          }
    </pre>
  </div>
  <!-- /.bl_codeBlock -->

        <p class="el_sectTxt">
          このように記述することで、ブロックモジュールの聖域を守りメンテナンス範囲の明確なコードを維持するだけでなく、他所へ移植した際もコンテキストに関わらず同じ状態を再現出来る、汎用性の高いモジュールになります。
        </p>

        <section id="modifyAchild" class="bl_sectBlock2">
          <h3 class="el_ttl2">Aモジュールの子要素に変更が生じる場合</h3>
          <p class="el_sectTxt">
            BモジュールがAモジュールに移植された際、場合によってはAモジュールの子要素に変更が生じることもあるでしょう。<br>
            その際のアプローチとして、考えられるパターンを3つ例示します。
          </p>
        <ul class="bl_simpleList">
          <li>Aの該当子要素モジュールに直接モディファイアを付加しスタイルを変更する</li>
          <li>Aモジュールにモディファイアを付加し、ネスト指定でスタイルを変更する</li>
          <li>元のAモジュールから分離した、Aモジュールの類似であるA2モジュールを作成する</li>
        </ul>
        <p class="el_sectTxt">
          どこまで拡張性を見据えるかにもよりますが、先に結論を言ってしまうと推奨するのは3つ目の<em class="el_caution">「類似であるA2モジュールを作成する」</em>です。<br>
          <span class="el_inlineCode">bl_imgBlock</span>と<span class="el_inlineCode">bl_sectBlock_txt</span>が左右ほぼ均等に横並び表示されるパターンを例に、それぞれ解説します。
        </p>
        <iframe class="el_iframe js_iframe" src="/sample/advance3.html"></iframe>
        <section id="modifyAchild_1" class="bl_sectBlock3">
          <h4 class="el_ttl3">Aの該当子要素モジュールに直接モディファイアを付加しスタイルを変更する</h4>
          
          
  <div class="bl_codeBlock">
    <em class="bl_codeBlock_ttl">HTML</em>
    <pre class="brush:html; class-name:''; highlight:[6,7]">
      
            &lt;div class=&#34;bl_sectBlock cf&#34;&gt;
              &lt;h2 class=&#34;bl_sectBlock_ttl&#34;&gt;.bl_sectBlock&lt;/h2&gt;
              &lt;div class=&#34;bl_imgBlock&#34;&gt;
                ...
              &lt;/div&gt;
              &lt;!-- 該当子要素モジュールにモディファイアの付加 --&gt;
              &lt;p class=&#34;bl_sectBlock_txt bl_sectBlock_txt__r49p&#34;&gt;
                ...
              &lt;/p&gt;
            &lt;/div&gt;
    </pre>
  </div>
  <!-- /.bl_codeBlock -->

          
          
  <div class="bl_codeBlock">
    <em class="bl_codeBlock_ttl">CSS</em>
    <pre class="brush:css; class-name:''; highlight:[8]">
      
              .bl_sectBlock{
                &gt; .bl_imgBlock{
                  width: 49%;
                  float: left;
                }
              }
              .bl_sectBlock_txt{
                &amp;.bl_sectBlock_txt__r49p{
                  float: right;
                  width: 49%;
                }
              }
    </pre>
  </div>
  <!-- /.bl_codeBlock -->

          <p class="el_sectTxt">
            このパターンは1番手っ取り早いですが、モディファイアを付加した該当モジュールしか調整出来ず、他のモジュールも調整が必要になった場合はいちいちモディファイアを付加しなければならないため、若干拡張性に欠けます。
          </p>
        </section>
        <!-- /.bl_sectBlock3 -->

        <section id="modifyAchild_2" class="bl_sectBlock3">
          <h4 class="el_ttl3">Aモジュールにモディファイアを付加し、ネスト指定でスタイルを変更する</h4>
          
          
  <div class="bl_codeBlock">
    <em class="bl_codeBlock_ttl">HTML</em>
    <pre class="brush:html; class-name:''; highlight:[1,2]">
      
            &lt;!-- Aモジュールにモディファイアの付加 --&gt;
            &lt;div class=&#34;bl_sectBlock bl_sectBlock__hasImgBlock cf&#34;&gt;
              &lt;h2 class=&#34;bl_sectBlock_ttl&#34;&gt;.bl_sectBlock&lt;/h2&gt;
              &lt;div class=&#34;bl_imgBlock&#34;&gt;
                ...
              &lt;/div&gt;
              &lt;p class=&#34;bl_sectBlock_txt&#34;&gt;
                ...
              &lt;/p&gt;
            &lt;/div&gt;
    </pre>
  </div>
  <!-- /.bl_codeBlock -->

          
          
  <div class="bl_codeBlock">
    <em class="bl_codeBlock_ttl">CSS</em>
    <pre class="brush:css; class-name:''; highlight:[]">
      
            .bl_sectBlock.bl_sectBlock__hasImgBlock{
              &gt; .bl_imgBlock{
                width: 49%;
                float: left;
              }
              &gt; .bl_sectBlock_txt{
                float: right;
                width: 49%;
              }
            }
    </pre>
  </div>
  <!-- /.bl_codeBlock -->

          <p class="el_sectTxt">
            前述と比較し、こちらのパターンは他の子要素にも調整が必要になった場合でもCSSを調整するだけで済みます。<br>
            モディファイア名は、拡張性を考慮すると子要素の状態に名前が左右されない<span class="el_inlineCode">bl_sectBlock__hasImgBlock</span>とすると良いでしょう。<br>
            ただし今回はネストしている別ブロックモジュールが一つなのでこれで十分ですが、仮にAモジュールにネストされるモジュールが増える、例えばBに加えCモジュールもAモジュールに組み込まれると、モディファイア名が冗長になることが予想されます。<br>
          </p>
          <p class="el_sectTxt">
            また<span class="el_inlineCode">**__has**</span>というモディファイア名にした場合、Bモジュールに対するスタイル指定も上記のCSSの例のようにモディファイアからのネストにした方が管理上健全ですが、仮に初めに例に挙げた「Aの子要素に影響を与えない、Bモジュールのネスト」と共存する場合、<em class="el_caution">「どちらもBモジュールを含むのに、片方だけに<span class="el_inlineCode">**__has**</span>モディファイアが付加されている」</em>となり、やはり少なからず論理的に破綻をきたしてしまいます。
          </p>
        </section>
        <!-- /.bl_sectBlock3 -->

        <section id="modifyAchild_3" class="bl_sectBlock3">
          <h4 class="el_ttl3">元のAモジュールから分離した、Aモジュールの類似であるA2モジュールを作成する</h4>
          
          
  <div class="bl_codeBlock">
    <em class="bl_codeBlock_ttl">HTML</em>
    <pre class="brush:html; class-name:''; highlight:[]">
      
              &lt;div class=&#34;bl_sectBlock2 cf&#34;&gt;
                &lt;h2 class=&#34;bl_sectBlock2_ttl&#34;&gt;.bl_sectBlock2&lt;/h2&gt;
                &lt;div class=&#34;bl_imgBlock&#34;&gt;
                  ...
                &lt;/div&gt;
                &lt;p class=&#34;bl_sectBlock2_txt&#34;&gt;
                  ...
                &lt;/p&gt;
              &lt;/div&gt;
    </pre>
  </div>
  <!-- /.bl_codeBlock -->

          
          
  <div class="bl_codeBlock">
    <em class="bl_codeBlock_ttl">CSS</em>
    <pre class="brush:css; class-name:''; highlight:[]">
      
              //重複スタイルの一括指定
              .bl_sectBlock,
              .bl_sectBlock2 {...}
              .bl_sectBlock_ttl,
              .bl_sectBlock2_ttl {...}
              .bl_sectBlock_txt_img,
              .bl_sectBlock2_txt_img {...}

              //bl_sectBlock独自の指定
              .bl_sectBlock_txt {...}

              //bl_sectBlock2独自の指定
              .bl_sectBlock2_txt {
                width: 49%;
                float: right;
              }
              .bl_sectBlock2 &gt; .bl_imgBlock {
                float: left;
                width: 49%;
              }
    </pre>
  </div>
  <!-- /.bl_codeBlock -->

          <p class="el_sectTxt">
            連番を付加し、元のモジュールの亜種として別モジュールを作成するパターンです。 変更が無い箇所にも再度同じスタイルを適用するのが少し手間ですが、元のAモジュールから分離できるため管理性・拡張性はかなり高いでしょう。<br>
            今回の例ではセレクタをカンマで区切っていますが、CSSプリプロセッサのextendやmixinを使用して管理することももちろん可能です。<br>
            タイトル部分など、共通部分をどうしても同一クラスで一元管理したいという場合は、エレメントモジュール化するという手もあります。
          </p>
        </section>
        <!-- /.bl_sectBlock3 -->
        </section>
        <!-- /.bl_sectBlock2 -->
      </section>
      <!-- /.bl_sectBlock -->
    </div>
    <!-- /.ly_main_inner -->
  </div>
  <!-- /.ly_main -->
</article>

<footer class="ly_footer">
  <div class="ly_footer_inner">
    <p class="el_centerTxt">
      PRECSS is maintained and funded by assialiholic.<br>
      Contributors &amp; Transrators wanted!<br>
      <a href="//github.com/assialiholic/precss/" target="_blank"><i class="fab fa-github fa-3x" aria-hidden="true"></i></a>
    </p>
  </div>
  <!-- /.ly_footer_inner -->
</footer>

<script src="http://cdn.jsdelivr.net/jquery/1.8.3/jquery-1.8.3.min.js"></script>
<script src="/js/scripts.js"></script>
</body>
</html>
