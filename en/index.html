
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>PRECSS - Manage your CSS with prefixes.</title>
  <meta name="description" content="PRECSS is a new modular architecture approach based on OOCSS, SMACSS and BEM.">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta property="og:type" content="website" />
  <meta property="og:site_name" content="PRECSS - Manage your CSS with prefixes." />
  <meta property="og:url" content="http://precss.io/" />
  <meta property="og:image" content="http://precss.io/images/ogimage.png" />
  <meta property="og:description" content="PRECSS is a new modular architecture approach based on OOCSS, SMACSS and BEM." />
  <meta name="twitter:card" content="summary_large_image" />
  <meta name="twitter:title" content="PRECSS - Manage your CSS with prefixes." />
  <meta name="twitter:domain" content="precss.io">
  <meta name="twitter:image" content="http://precss.io/images/ogimage.png" />
  <meta name="twitter:description" content="PRECSS is a new modular architecture approach based on OOCSS, SMACSS and BEM.">
  <link rel="shortcut icon" href="/images/favicon.ico" />
  <link rel="stylesheet" href="/css/main.css">
  <script defer src="//use.fontawesome.com/releases/v5.0.9/js/all.js" integrity="sha384-8iPTk2s/jMVj81dnzb/iFR2sdA7u06vHJyyLlAd4snFpCl/SnyUjRrbdJsw1pGIl" crossorigin="anonymous"></script>
  <link href='//fonts.googleapis.com/css?family=Source+Sans+Pro|Rokkitt' rel='stylesheet' type='text/css'>
</head>
<body>
<header class="ly_header">
    <div class="ly_header_inner">
      <div class="bl_headerConts">
        <p class="bl_headerConts_logo"><img src="/images/logo.svg" alt="PRE_CSS"></p>
        <ul class="bl_headerConts_nav">
          <li><i class="fab fa-github" aria-hidden="true"></i><a href="//github.com/assialiholic/precss/" target="_blank">GitHub</a></li>
        </ul>
      </div>
      <!-- /.bl_headerConts -->
    </div>
    <!-- /.ly_header_inner -->
    <section class="bl_MV">
      <div class="bl_MV_inner">
        <h1 class="bl_MV_ttl">Manage your CSS<br>with prefixes.</h1>
        <!-- <p class="bl_MV_img"><img src="/images/MV.png" alt=""></p> -->
        <pre class="bl_MV_code js_split">
          &lt;div class="<span class="hp_cBlue">ly_header</span>"&gt;...&lt;/div&gt;&nbsp;&nbsp;<span class="hp_cGray hp_fsi">&lt;!-- layout --&gt;</span>
          &lt;div class="<span class="hp_cBlue">ly_main</span>"&gt;
              &lt;div class="<span class="hp_cGreen">bl_sectBlock</span>"&gt;&nbsp;&nbsp;<span class="hp_cGray hp_fsi">&lt;!-- block module --&gt;</span>
                  &lt;h2 class="<span class="hp_cGreen">bl_sectBlock_ttl</span>"&gt;PRECSS&lt;/h2&gt;
                  &lt;p class="<span class="hp_cGreen">bl_sectBlock_txt</span> <span class="hp_cViolet">hp_mb20</span>"&gt;CSS with prefixes.&lt;/p&gt;&nbsp;&nbsp;<span class="hp_cGray hp_fsi">&lt;!-- helper --&gt;</span>
              &lt;/div&gt;
          &lt;/div&gt;
          &lt;div class="<span class="hp_cBlue">ly_side</span>"&gt;
              &lt;a href="#" class="<span class="hp_cOrange">el_btn</span>"&gt;Try PRECSS&lt;/a&gt;&nbsp;&nbsp;<span class="hp_cGray hp_fsi">&lt;!-- element module --&gt;</span>
              &lt;a href="#" class="<span class="hp_cOrange">el_btn</span> <span class="hp_cRed">el_btn__blue</span>"&gt;Back&lt;/a&gt;&nbsp;&nbsp;<span class="hp_cGray hp_fsi">&lt;!-- modifier --&gt;</span>
          &lt;/div&gt;
          &lt;div class="<span class="hp_cBlue">ly_footer</span>"&gt;...&lt;/div&gt;
        </pre>
      </div>
      <!-- /.bl_MV_inner -->
    </section>
    <!-- /.bl_MV -->
</header>
<article>
  <div class="ly_main">
    <div class="ly_main_inner">
      <section class="bl_catch">
        <h2 class="bl_catch_head">Powerful modular design that has taken over the splendor of OOCSS, SMACSS, and BEM skillfully and has evolved further. That is PRECSS.</h2>
        <div class="bl_featureUnit bl_featureUnit__col2 cf">
          <dl class="bl_featureBlock">
            <dt><i class="fas fa-sort-alpha-down hp_fz1_5e" aria-hidden="true"></i><br>Add prefix to everything</dt>
            <dd>
              All classes managed by PRECSS are prefixed according to their type. By doing this, you can grasp all the roles, scopes and dependencies by looking at the prefix at a glance.<br>
              Please do not bother with the size of the module anymore.
            </dd>
          </dl>
          <dl class="bl_featureBlock">
            <dt><i class="fa fa-check-circle hp_fz1_3e" aria-hidden="true"></i><br>Optimized naming convention</dt>
            <dd>
              All class names consist of a mixture of snake case and camel case, and there are clear rules for using them properly.<br>
              As it also shows guidelines on abbreviations, as I have been worried about as I have ever been, there is no need to give very long names.
            </dd>
          </dl>
        </div>
        <!-- /.bl_featureUnit -->
        <div class="bl_featureUnit bl_featureUnit__col3 cf">
          <dl class="bl_featureBlock">
            <dt class="js_matchHeight"><i class="fa fa-heart hp_fz1_3e" aria-hidden="true"></i><br>Friendly design</dt>
            <dd>
              PRECSS is not a completely new design philosophy. It is based on OOCSS, SMACSS, BEM etc. such a wonderful thought to be praised so far.<br>
              The more you are a modern developer, the more PRECSS will feel familiar.
            </dd>
          </dl>
          <dl class="bl_featureBlock">
            <dt class="js_matchHeight"><i class="fa fa-users hp_fz1_5e" aria-hidden="true"></i><br>Coexistence with other tribes</dt>
            <dd>
              With clear, proprietary notation, you will be able to clearly distinguish between the classes you wrote and the classes output by the CMS or CSS framework.<br>
              PRECSS does not have to comply with all the rules of PRECSS, but flexibility to accept other people is also in PRECSS.
            </dd>
          </dl>
          <dl class="bl_featureBlock">
            <dt class="js_matchHeight"><i class="fas fa-expand-arrows-alt hp_fz1_3e" aria-hidden="true"></i><br>Extensible</dt>
            <dd>
              If you need a valid class only for smartphones, you may want to create a group with the prefix ".sp_**".<br>
              PRECSS basically consists of 6 groups each with its own prefix, but it can also be expanded as necessary.
            </dd>
          </dl>
        </div>
        <!-- /.bl_featureUnit bl_featureUnit__col3 -->
      </section>
    </div>
    <!-- /.ly_main_inner -->
  </div>
  <!-- /.ly_main -->

  <nav class="ly_stickySide js_stickySide js_closeParent">
    <div class="js_stickyInner">
      <a href="close" class="el_closeBtn js_closeBtn">×</a>
      <ul class="bl_utickyList">
      <li><a href="#rule">notation</a></li>
      <li class="hp_mb30"><a href="#nameRule">Naming convention</a>
        <ul class="bl_simpleList02">
          <li><a href="#nameRule_general">Generic usable name</a></li>
          <li><a href="#nameRule_omission">When omitting a word</a></li>
          <li><a href="#nameRule_series">When forming a series</a></li>
        </ul>
      </li>
      <li><a href="#base">Base</a></li>
      <li><a href="#layout">Layout</a></li>
      <li>
        <a href="#block">Block module</a>
        <ul class="bl_simpleList02">
          <li><a href="#block_applicable">Applicable style</a></li>
          <li><a href="#block_nameSize">The granularity of concept / naming</a></li>
        </ul>
      </li>
      <li>
        <a href="#element">Element module</a>
        <ul class="bl_simpleList02">
          <li><a href="#element_layout">About the layout</a></li>
        </ul>
      </li>
      <li>
        <a href="#modifier">Modifier</a>
        <ul class="bl_simpleList02">
          <li><a href="#modifier_element">Element module example</a></li>
          <li><a href="#modifier_block">Block module example</a></li>
        </ul>
      </li>
      <li>
        <a href="#helper">Helper</a>
        <ul class="bl_simpleList02">
          <li><a href="#helper_clearfix">About clearfix</a></li>
        </ul>
      </li>
      <li><a href="#unique">Unique</a></li>
      <li><a href="#program">Program</a></li>
      <li class="hp_mb30"><a href="#original">Original</a></li>
      <li>
        <a href="#nestedModule">When modules are nested in other modules</a>
        <ul class="bl_simpleList02">
          <li><a href="#modifyAchild">Changes in child elements of module A</a></li>
          <li><a href="#modifyAchild_1">Modify the style by adding a modifier directly to the corresponding child element module of A</a></li>
          <li><a href="#modifyAchild_2">Modifier is added to A module and style is changed by nest designation</a></li>
          <li><a href="#modifyAchild_3">Create an A2 module that is similar to the A module, separated from the original A module</a></li>
        </ul>
      </li>
      </ul>
    </div>
    <!-- /.js_stickyInner -->
  </nav>
  <!-- /.ly_stickySide -->

  <div class="bl_sectBlockCalm">
    <p class="bl_sectBlockCalm_txt">Basics</p>
  </div>
  <!-- /.bl_sectBlockCalm -->

  <div class="ly_main">
    <div class="ly_main_inner">
      <section class="bl_sectBlock">
        <h2 id="rule" class="el_ttl">Notation</h2>
        <p class="el_sectTxt">
        For CSS description method itself, we recommend that you basically follow the <a href="https://google.github.io/styleguide/htmlcssguide.xml" target="_blank">Google HTML/CSS Style Guide</a> , <a href="https://github.com/necolas/idiomatic-css" target="_blank">Principles of writing consistent, idiomatic CSS</a> .
        </p>
      </section>
      <section class="bl_sectBlock">
        <div id="nameRule" class="bl_sectBlock">
          <h2 class="el_ttl">Naming convention</h2>
          <p class="el_sectTxt">
            PRECSS adds 2 letter prefixes according to the type to all classes intentionally described.
            All prefixes and words are joined in a snake case based on the structure, and if there are multiple words in one structure, use only the part of the camel case.
            Basically, we do not use the ID attribute for the style, it all comes with the class attribute.
          </p>
          
          
  <div class="bl_codeBlock">
    <em class="bl_codeBlock_ttl">Not recommended</em>
    <pre class="brush:html; class-name:'light'; highlight:[]">
      
            &lt;div class=&#34;bl_img_block&#34;&gt;
              &lt;div class=&#34;bl_img_block_header&#34;&gt;
                ...
              &lt;/div&gt;
              &lt;div class=&#34;bl_img_block_body&#34;&gt;
                ...
              &lt;/div&gt;
            &lt;/div&gt;
    </pre>
  </div>
  <!-- /.bl_codeBlock -->

          
          
  <div class="bl_codeBlock">
    <em class="bl_codeBlock_ttl">Recommended</em>
    <pre class="brush:html; class-name:''; highlight:[]">
      
            &lt;div class=&#34;bl_imgBlock&#34;&gt;
              &lt;div class=&#34;bl_imgBlock_header&#34;&gt;
                ...
              &lt;/div&gt;
              &lt;div class=&#34;bl_imgBlock_body&#34;&gt;
                ...
              &lt;/div&gt;
            &lt;/div&gt;
    </pre>
  </div>
  <!-- /.bl_codeBlock -->

        </div>
        <!-- /.bl_sectBlock -->

        <section id="nameRule_general" class="bl_sectBlock2">
          <h5 class="el_ttl2">Generic usable name</h5>
          <ul class="bl_simpleList">
            <li>_wrapper</li>
            <li>_inner</li>
            <li>_header</li>
            <li>_body</li>
            <li>_footer</li>
          </ul>
          <p class="el_sectTxt">These can be used for general purpose as necessary in any of the 5 groups described later.
Especially in <span class="el_inlineCode">_wrapper</span> and <span class="el_inlineCode">_inner</span>, it is clear as structure, redundancy increases on the contrary, so it is not necessary to let its child elements inherit the name.
          </p>
          
          
  <div class="bl_codeBlock">
    <em class="bl_codeBlock_ttl">Not recommended</em>
    <pre class="brush:html; class-name:'light'; highlight:[]">
      
            &lt;div class=&#34;bl_imgBlock_wrapper&#34;&gt;
              &lt;div class=&#34;bl_imgBlock_wrapper_inner&#34;&gt;
                &lt;div class=&#34;bl_imgBlock_wrapper_inner_header&#34;&gt;
                  ...
                &lt;/div&gt;
              &lt;/div&gt;
            &lt;/div&gt;
    </pre>
  </div>
  <!-- /.bl_codeBlock -->

          
          
  <div class="bl_codeBlock">
    <em class="bl_codeBlock_ttl">Recommended</em>
    <pre class="brush:html; class-name:''; highlight:[]">
      
            &lt;div class=&#34;bl_imgBlock_wrapper&#34;&gt;
              &lt;div class=&#34;bl_imgBlock&#34;&gt;
                &lt;div class=&#34;bl_imgBlock_inner&#34;&gt;
                  &lt;div class=&#34;bl_imgBlock_header&#34;&gt;
                    ...
                  &lt;/div&gt;
                &lt;/div&gt;
              &lt;/div&gt;
            &lt;/div&gt;
    </pre>
  </div>
  <!-- /.bl_codeBlock -->

        </section>
        <!-- /.bl_sectBlock2 -->

        <section id="nameRule_omission" class="bl_sectBlock2">
          <h3 class="el_ttl2">When omitting a word</h3>
          <p class="el_sectTxt">
          Module design in CSS is a very wonderful idea, but it is inevitable that naming becomes redundant.
          Although PRECSS does not set any particular rules, we recommend that you follow the <a href="https://goo.gl/VblUdM" target="_blank">Google HTML/CSS Style Guide</a> if you omit words.
          Also, it is also recommended to express only one capitalized word group with two or more words with uppercase letters of each initial letter. However, it is preferable that there are patterns that are somewhat general or continuous. <br>
          <br>
          In addition, we present words that are commonly used as reference.
          </p>
          <dl class="bl_definitionList">
            <dt>Common examples</dt>
            <dd>・mainVisual→MV</dd>
          </dl>
          <dl class="bl_definitionList">
            <dt>Examples of consecutive patterns</dt>
            <dd>・northEurope→NE</dd>
            <dd>・northAmerica→NA</dd>
            <dd>・centralSouthAmerica→CSA</dd>
          </dl>
          <dl class="bl_definitionList">
            <dt>Commonly used abbreviations</dt>
            <dd class="sp_ovs">
              <table class="bl_colTable hp_ML1e hp_ti0">
                <tr>
                  <th>Sections</th>
                  <td>cat - category</td>
                  <td>col/cl - colomn</td>
                  <td>cont/conts - content(s)</td>
                  <td>lv - level</td>
                  <td>sect - section</td>
                </tr>
                <tr>
                  <th rowspan="2">Simples</th>
                  <td>btn - button</td>
                  <td>cf - clearfix</td>
                  <td>img - image</td>
                  <td>lnk - link</td>
                  <td>num - number</td>
                </tr>
                <tr>
                  <td>txt - text</td>
                  <td>ttl - title</td>
                  <td>&nbsp;</td>
                  <td>&nbsp;</td>
                  <td>&nbsp;</td>
                </tr>
                <tr>
                  <th>Modifiers</th>
                  <td>lrg - large</td>
                  <td>l - left</td>
                  <td>rev - reverse</td>
                  <td>r - right</td>
                  <td>sml - small</td>
                </tr>
              </table>
            </dd>
          </dl>
        </section>
        <!-- /.bl_sectBlock2 -->

        <section id="nameRule_series" class="bl_sectBlock2">
          <h3 class="el_ttl2">When forming a series</h3>
           <p class="el_sectTxt">
             We recommend that you manage serial numbers for items that are similar. However, the first one will not be numbered consecutively, regardless of whether it forms a series or not.
          </p>
          
          
  <div class="bl_codeBlock">
    <em class="bl_codeBlock_ttl">Not recommended</em>
    <pre class="brush:html; class-name:'light'; highlight:[1]">
      
            &lt;div class=&#34;bl_imgBlock1&#34;&gt;...&lt;/div&gt;
            &lt;div class=&#34;bl_imgBlock2&#34;&gt;...&lt;/div&gt;
            &lt;div class=&#34;bl_imgBlock3&#34;&gt;...&lt;/div&gt;
    </pre>
  </div>
  <!-- /.bl_codeBlock -->

          
          
  <div class="bl_codeBlock">
    <em class="bl_codeBlock_ttl">Recommended</em>
    <pre class="brush:html; class-name:''; highlight:[1]">
      
            &lt;div class=&#34;bl_imgBlock&#34;&gt;...&lt;/div&gt;
            &lt;div class=&#34;bl_imgBlock2&#34;&gt;...&lt;/div&gt;
            &lt;div class=&#34;bl_imgBlock3&#34;&gt;...&lt;/div&gt;
    </pre>
  </div>
  <!-- /.bl_codeBlock -->

        </section>
        <!-- /.bl_sectBlock2 -->
      </section>
      <!-- /.bl_sectBlock -->
    </div>
    <!-- /.ly_main_inner -->
  </div>
  <!-- /.ly_main -->

<div class="bl_sectBlockCalm">
  <p class="bl_sectBlockCalm_txt">Documentation</p>
</div>
<!-- /.bl_sectBlockCalm -->

  <div class="ly_main hp_bgcLightPink">
    <div class="ly_main_inner">
      <section class="bl_sectBlock">
        <div class="bl_sectBlock">
          <h2 class="el_ttl">Basic Design</h2>
          <p class="el_sectTxt">
            PRECSS consists of the following six groups.<br>
            <span class="el_note">※ The source code contains only the descriptions necessary for explanation at a minimum.</span>
          </p>
          <ol class="bl_simpleList">
          <li><a href="#base">Base</a></li>
            <li><a href="#layout">Layout</a></li>
            <li>
              <a href="#module">Module</a>
              <ol class="bl_simpleList hp_mb0">
              <li><a href="#block">Block Module</a></li>
                <li><a href="#element">Element Module</a></li>
              </ol>
            </li>
            <li><a href="#helper">Helper</a></li>
            <li><a href="#unique">Unique</a></li>
            <li><a href="#program">Program</a></li>
            <li><a href="#original">(Original)</a></li>
          </ol>
        </div>
        <!-- /.bl_sectBlock -->

        <section id="base" class="bl_sectBlock2">
          <h3 class="el_ttl2">1.Base</h3>
          <p class="el_sectTxt">
            <em class="el_note2">Prefix: None</em>
          </p>
          <p class="el_sectTxt">
            We treat bases the same way as SMACSS. In addition to making bases with reset.css and normalize.css, specify the styles related to the whole site directly to the element selector.
PRECSS also allows the application of limited base styles within specific scopes.
For example, we use a limited base style when "I want all the links in the header to be white, but the inside of the footer should be blue." (However, please be careful as it is an act of increasing detail level)
          </p>
          
          
  <div class="bl_codeBlock">
    <em class="bl_codeBlock_ttl">CSS</em>
    <pre class="brush:css; class-name:''; highlight:[]">
      
            .ly_header a {
              color: #fff;
            }
            .ly_footer a {
              color: blue;
            }
    </pre>
  </div>
  <!-- /.bl_codeBlock -->

        </section>
        <!-- /.bl_sectBlock2 -->

        <section id="layout" class="bl_sectBlock2">
          <h3 class="el_ttl2">2.Layout</h3>
          <p class="el_sectTxt">
            <em class="el_note2">Prefix: ly_</em>
          </p>
          <p class="el_sectTxt">
            ly stands for layout. It is used for elements that form large layouts such as headers, body areas, main areas, side areas, and footers.
          </p>
          <iframe class="el_iframe js_iframe" src="/sample/layout.html"></iframe>
          
          
  <div class="bl_codeBlock">
    <em class="bl_codeBlock_ttl">HTML</em>
    <pre class="brush:html; class-name:''; highlight:[]">
      
            &lt;header class=&#34;ly_header&#34;&gt;
              ...
            &lt;/header&gt;
            &lt;div class=&#34;ly_body&#34;&gt;
              &lt;div class=&#34;ly_main&#34;&gt;
                ...
              &lt;/div&gt;
              &lt;div class=&#34;ly_side&#34;&gt;
                ...
              &lt;/div&gt;
            &lt;/div&gt;
            &lt;footer class=&#34;ly_footer&#34;&gt;
              ...
            &lt;/footer&gt;
    </pre>
  </div>
  <!-- /.bl_codeBlock -->

          
          
  <div class="bl_codeBlock">
    <em class="bl_codeBlock_ttl">CSS</em>
    <pre class="brush:css; class-name:''; highlight:[]">
      
            .ly_header {
              background-color: #f4d9d9;
            }
            .ly_body {
              width: 100%
              max-width: 960px;
              margin: 0 auto;
              background-color: #f9ebd1;
            }
            .ly_main {
              float: left;
              width: 68%;
              background-color: #d7f5e0;
            }
            .ly_side {
              float: right;
              width: 30%;
              background-color: #ecefc9;
            }
            .ly_footer {
              background-color: #dbd9e5;
            }
    </pre>
  </div>
  <!-- /.bl_codeBlock -->

        </section>
        <!-- /.bl_sectBlock2 -->

        <section id="module" class="bl_sectBlock2">
          <h3 class="el_ttl2">3.Module</h3>
          <p class="el_sectTxt">
            PRECSS manages highly portable code as a module.
          </p>

          <section id="block" class="bl_sectBlock3">
            <h4 class="el_ttl3">3-1.Block module</h4>
            <p class="el_sectTxt">
              <em class="el_note2">Prefix: bl_</em>
            </p>
            <p class="el_sectTxt">
bl stands for block. A module group that contains multiple child elements peculiar to the block module and an element module to be described later and that <em class="el_caution">can be carried as one chunk is formed.</em>
Child elements of the block module basically inherit the parent 's name, and clarify the structure by joining by an underscore as it becomes a child.
            </p>
            <iframe class="el_iframe js_iframe" src="/sample/blockModule.html"></iframe>
            
            
  <div class="bl_codeBlock">
    <em class="bl_codeBlock_ttl">HTML</em>
    <pre class="brush:html; class-name:''; highlight:[]">
      
              &lt;div class=&#34;bl_sectBlock&#34;&gt;
                &lt;h2 class=&#34;bl_sectBlock_ttl&#34;&gt;.bl_sectBlock&lt;/h2&gt;
                &lt;p class=&#34;bl_sectBlock_txt&#34;&gt;
                  &lt;img class=&#34;bl_sectBlock_txt_img&#34; src=&#34;&#34;&gt;
                  Lorem ipsum...
                &lt;/p&gt;
              &lt;/div&gt;

              &lt;div class=&#34;bl_imgBlock&#34;&gt;
                &lt;h3 class=&#34;bl_imgBlock_ttl&#34;&gt;.bl_imgBlock&lt;/h3&gt;
                &lt;p class=&#34;bl_imgBlock_img&#34;&gt;&lt;img src=&#34;&#34;&gt;&lt;/p&gt;
                &lt;p class=&#34;bl_imgBlock_txt&#34;&gt;
                  Lorem ipsum...
                &lt;/p&gt;
              &lt;/div&gt;
    </pre>
  </div>
  <!-- /.bl_codeBlock -->

            
            
  <div class="bl_codeBlock">
    <em class="bl_codeBlock_ttl">CSS</em>
    <pre class="brush:css; class-name:''; highlight:[]">
      
              .bl_sectBlock {
                padding: 1%;
                margin: 0 0 20px 0;
                border: 1px solid #ccc;
              }
              .bl_sectBlock_ttl {...}
              .bl_sectBlock_txt {...}
              .bl_sectBlock_txt_img {...}

              .bl_imgBlock {
                padding: 1%;
                margin: 0 0 20px 0;
                border: 1px solid #ccc;
                text-align: center;
              }
              .bl_imgBlock_ttl {...}
              .bl_imgBlock_img {
                &gt; img {...}
              }
              .bl_imgBlock_txt {...}
    </pre>
  </div>
  <!-- /.bl_codeBlock -->


            <p class="el_sectTxt">
            As with SMACSS, PRECSS allows you to directly specify a style for tags of child elements. In that case, however, it is recommended that you specify it with a child selector as much as possible, and add unique classes for non semantic elements such as <span class="el_inlineCode">div</span> and <span class="el_inlineCode">span</span>.
            Also, if too much hierarchy becomes too deep, there is a risk that influence may be exerted on code outlook and detail level management, so nesting is limited to about 3 levels, and if it is likely to be more than that, add classes as appropriate We recommend.
            </p>
            
            
  <div class="bl_codeBlock">
    <em class="bl_codeBlock_ttl">HTML</em>
    <pre class="brush:html; class-name:''; highlight:[]">
      
                &lt;ul class=&#34;bl_circleList&#34;&gt;
                  &lt;li&gt;list 1&lt;/li&gt;
                  &lt;li&gt;list 2&lt;/li&gt;
                &lt;/ul&gt;
    </pre>
  </div>
  <!-- /.bl_codeBlock -->

            
            
  <div class="bl_codeBlock">
    <em class="bl_codeBlock_ttl">CSS</em>
    <pre class="brush:css; class-name:''; highlight:[]">
      
                .bl_circleList {
                  padding-left: 1em;
                  margin: 0 0 20px 0;
                }
                .bl_circleList &gt; li {
                  list-style-type: circle;
                }
    </pre>
  </div>
  <!-- /.bl_codeBlock -->


            <section id="block_applicable" class="bl_sectBlock4">
            <h5 class="el_ttl4">Styles applicable to block modules</h5>
            <p class="el_sectTxt">
                As a precaution, only <em class="el_caution">block styles that do not affect other elements are applied to the block module</em> ( <span class="el_inlineCode">margin-top / bottom</span> is directly applicable as an exception).
                Styles affecting other styles, that is, those related to layouts such as <span class="el_inlineCode">float</span> and <span class="el_inlineCode">width</span> , apply styles in a nested manner from further parents.
                <em class="el_caution">That is, it is desirable that the initial value of the width of the block module is 100% as much as possible</em> , which realizes high scalability and portability.
                This behavior is easier to understand by considering a block module with columns as an example.
            </p>
              <section class="bl_sectBlock5">
                <h6 class="el_ttl5">One column example</h5>
                <p class="bl_sectBlock5_txt">
                    In this example, this is the smallest block module, so you can use it alone by not specifying layout, and you can port it anywhere.
                </p>
                <iframe class="el_iframe js_iframe" src="/sample/blockModule2.html"></iframe>
                
                
  <div class="bl_codeBlock">
    <em class="bl_codeBlock_ttl">HTML</em>
    <pre class="brush:html; class-name:''; highlight:[]">
      
                  &lt;div class=&#34;bl_imgBlock&#34;&gt;
                    &lt;h3 class=&#34;bl_imgBlock_ttl&#34;&gt;bl_imgBlock&lt;/h3&gt;
                    &lt;p class=&#34;bl_imgBlock_img&#34;&gt;&lt;img src=&#34;//goo.gl/7lQK1g&#34;&gt;&lt;/p&gt;
                    &lt;p class=&#34;bl_imgBlock_txt&#34;&gt;
                      Lorem ipsum...
                    &lt;/p&gt;
                  &lt;/div&gt;
    </pre>
  </div>
  <!-- /.bl_codeBlock -->

                
                
  <div class="bl_codeBlock">
    <em class="bl_codeBlock_ttl">CSS</em>
    <pre class="brush:css; class-name:''; highlight:[]">
      
                  .bl_imgBlock {
                    margin: 0 0 20px 0;
                    border: 1px solid #ccc;
                    text-align: center;
                  }
                  .bl_imgBlock_ttl {
                    font-weight: bold;
                    font-size: 1em;
                  }
                  .bl_imgBlock_img {
                    &gt; img {
                      width: 100%;
                      max-width: 100px;
                    }
                  }
                  .bl_imgBlock_txt {
                    line-height: 1.2;
                  }
    </pre>
  </div>
  <!-- /.bl_codeBlock -->

              </section>
              <!-- /.bl_sectBlock5 -->

              <section class="bl_sectBlock5">
                <h6 class="el_ttl5">Example of multiple columns</h5>
                <p class="bl_sectBlock5_txt">
                    By wrapping it with an element called <span class="el_inlineCode">bl_imgUnit</span>, you can reuse it without compromising the above block module (in this case, if you also need to change <span class="el_inlineCode">margin-top / bottom</span> , overwrite it as well).
                    Since <span class="el_inlineCode">bl_imgUnit</span> itself has become a high-order block module, <em class="el_caution"><span class="el_inlineCode">bl_imgUnit</span> can be ported to others in the future as well .</em>
                    Also, by controlling the width from the modifier according to the number of columns, we realize high scalability.
                </p>
                <iframe class="el_iframe js_iframe" src="/sample/blockModule3.html"></iframe>
                
                
  <div class="bl_codeBlock">
    <em class="bl_codeBlock_ttl">HTML</em>
    <pre class="brush:html; class-name:''; highlight:[1,11]">
      
                  &lt;div class=&#34;bl_imgUnit bl_imgUnit__col2&#34;&gt;
                    &lt;h2 class=&#34;el_blName&#34;&gt;.bl_imgUnit__col2&lt;/h2&gt;
                    &lt;div class=&#34;bl_imgBlock&#34;&gt;
                      ...
                    &lt;/div&gt;
                    &lt;div class=&#34;bl_imgBlock&#34;&gt;
                      ...
                    &lt;/div&gt;
                  &lt;/div&gt;

                  &lt;div class=&#34;bl_imgUnit bl_imgUnit__col3&#34;&gt;
                    &lt;h2 class=&#34;el_blName&#34;&gt;.bl_imgUnit__col3&lt;/h2&gt;
                    &lt;div class=&#34;bl_imgBlock&#34;&gt;
                      ...
                    &lt;/div&gt;
                    &lt;div class=&#34;bl_imgBlock&#34;&gt;
                      ...
                    &lt;/div&gt;
                    &lt;div class=&#34;bl_imgBlock&#34;&gt;
                      ...
                    &lt;/div&gt;
                  &lt;/div&gt;
    </pre>
  </div>
  <!-- /.bl_codeBlock -->

                
                
  <div class="bl_codeBlock">
    <em class="bl_codeBlock_ttl">CSS</em>
    <pre class="brush:css; class-name:''; highlight:[]">
      
                  .bl_imgUnit {
                    margin: 0 0 20px 0;
                    border: 1px solid #ccc;
                    text-align: center;
                    &gt; .bl_imgBlock {
                      display: inline-block;
                      margin: 0 2% 0 0;
                      &amp;:last-child {
                        margin-right: 0;
                      }
                    }
                  }
                  .bl_imgUnit__col2 {
                    &gt; .bl_imgBlock {
                      width: 47%;
                    }
                  }
                  .bl_imgUnit__col3 {
                    &gt; .bl_imgBlock {
                      width: 30%;
                    }
                  }
    </pre>
  </div>
  <!-- /.bl_codeBlock -->

              </section>
              <!-- /.bl_sectBlock5 -->
              <p class="bl_sectBlock5_txt">
                  An extreme example is as follows when porting these to each of the main area and side area.
              </p>
              <iframe class="el_iframe js_iframe" src="/sample/blockModule4.html"></iframe>
            </section>
            <!-- /.bl_sectBlock4 -->

            <p class="el_sectTxt">
                As mentioned above, the block module is extremely flexible and can run around in the powerfully.
                However, in order to maintain its high portability, it is necessary to have a slight special technique called nesting from higher order, and you will have trouble out of it unfamiliar.
                For porting more complicated block modules, we summarized as <a href="#nestedModule">Advance Case</a> at the bottom, so please refer to that.
            </p>
            <p class="el_sectTxt">
                We also provide guidelines for granularity to help you name block modules below.
                Block modules play a very important role in PRECSS, so we do not recommend omitting these words.
                We do not necessarily have to include these names, but referring to these will help you strongly to manipulate the block module freely (as a matter of fact, it's a size larger than Unit There is not much to use).
            </p>

            <section id="block_nameSize" class="bl_sectBlock4">
              <h5 class="el_ttl4">The granularity of concept and naming in block modules</h5>
              <ul class="bl_simpleList">
                <li>Block - the basic unit of a block module. Includes multiple child elements specific to the module and element modules</li>
                <li>Unit - Block gathering</li>
                <li>Box - Unit gatherings</li>
                <li>Container - Box meeting</li>
              </ul>
            </section>
            <!-- /.bl_sectBlock4 -->
          </section>
          <!-- /.bl_sectBlock3 -->

          <section id="element" class="bl_sectBlock3">
            <h4 class="el_ttl3">3-2.Element Module</h4>
            <p class="el_sectTxt">
              <em class="el_note2">Prefix: el_</em>
            </p>
            <p class="el_sectTxt">
                el stands for element. It is a module of the smallest unit such as buttons, labels, headlines, etc. It is possible to carry by itself.
                We recommend naming <em class="el_caution">as versatile as possible</em> . This is a measure to keep the name and content from deviating regardless of what kind of content it enters as content.<br>
                <span class="el_note">※However, if the style and the naming match semantically within the site, that does not mean that (for example, if the label of the product or brand and the theme color are attached).</span>
            </p>
            <p class="el_sectTxt">
                If there are multiple element modules of similar style, use the concept of structure and skin in OOCSS.
                Individual skins are implemented with a modifier to be described later.
            </p>

            <iframe class="el_iframe js_iframe" src="/sample/elementModule.html"></iframe>
            
            
  <div class="bl_codeBlock">
    <em class="bl_codeBlock_ttl">Not recommended(HTML)</em>
    <pre class="brush:html; class-name:'light'; highlight:[1,4,5,11,12]">
      
              &lt;!-- names are not universal --&gt;
              &lt;div class=&#34;bl_sectBlock&#34;&gt;
                &lt;h2 class=&#34;bl_sectBlock_ttl&#34;&gt;.bl_sectBlock
                  &lt;span class=&#34;el_label el_label__news&#34;&gt;News&lt;/span&gt;
                  &lt;span class=&#34;el_label el_label__blog&#34;&gt;Blog&lt;/span&gt;
                &lt;/h2&gt;
                ...
              &lt;/div&gt;

              &lt;p class=&#34;hp_tac&#34;&gt;
                &lt;a href=&#34;&#34; class=&#34;el_btn el_btn__cancel&#34;&gt;Cancel&lt;/a&gt;
                &lt;a href=&#34;&#34; class=&#34;el_btn el_btn__submit&#34;&gt;Submit&lt;/a&gt;
              &lt;/p&gt;
    </pre>
  </div>
  <!-- /.bl_codeBlock -->

            
            
  <div class="bl_codeBlock">
    <em class="bl_codeBlock_ttl">Recommended(HTML)</em>
    <pre class="brush:html; class-name:''; highlight:[3,4,10,11]">
      
              &lt;div class=&#34;bl_sectBlock&#34;&gt;
                &lt;h2 class=&#34;bl_sectBlock_ttl&#34;&gt;.bl_sectBlock
                  &lt;span class=&#34;el_label el_label__red&#34;&gt;News&lt;/span&gt;
                  &lt;span class=&#34;el_label el_label__blue&#34;&gt;Blog&lt;/span&gt;
                &lt;/h2&gt;
                ...
              &lt;/div&gt;

              &lt;p class=&#34;hp_tac&#34;&gt;
                &lt;a href=&#34;&#34; class=&#34;el_btn el_btn__blue&#34;&gt;Cancel&lt;/a&gt;
                &lt;a href=&#34;&#34; class=&#34;el_btn el_btn__orange&#34;&gt;Submit&lt;/a&gt;
              &lt;/p&gt;
    </pre>
  </div>
  <!-- /.bl_codeBlock -->

            
            
  <div class="bl_codeBlock">
    <em class="bl_codeBlock_ttl">Recommended(CSS)</em>
    <pre class="brush:css; class-name:''; highlight:[]">
      
              .el_label {
                display: inline-block;
                padding: .2em .5em;
                color: #fff;
                &amp;.el_label__red {
                  background-color: #de5b5b;
                }
                &amp;.el_label__blue {
                  background-color: #308EDE;
                }
              }

              .el_btn {
                display: inline-block;
                max-width: 200px;
                padding: .5em 1em;
                margin-bottom: 20px;
                border-radius: 5px;
                color: #fff;
                text-align: center;
                &amp;.el_btn__orange {
                  background-color: #E18700;
                  box-shadow: 0 3px 0 #B85F29;
                }
                &amp;.el_btn__blue {
                  background-color: #308EDE;
                  box-shadow: 0 3px 0 #2572B1;
                }
              }

              .hp_tac {
                text-align: center !important;
              }
    </pre>
  </div>
  <!-- /.bl_codeBlock -->


            <section id="element_layout" class="bl_sectBlock4">
            <h5 class="el_ttl4">About the layout</h5>
              <p class="el_sectTxt">
                  To maintain portability, em.el_caution like block modules.
                  Ideally it is nested from the destination module, or some parent element like <span class="el_inlineCode">.hp_tac</span> above. ( <span class="el_inlineCode">.hp_</span> is explained in the next helper section)
                  However, as there are often variations in the element module compared to the block module, it is permissible to directly specify the width and create a size pattern with the modifier.
                  However, fixing <span class="el_inlineCode">___w250(px)</span> and a fixed number will make it <em class="el_caution">the first step toward failure</em> if inconsistency occurs between the modifier number and the actual size when adopting responsive web design and becoming SP view Please keep in mind.
                  Depending on the situation, if possible use <span class="el_inlineCode">inline-block</span> to make the size variable, it will be useful.
                  Of course it is also possible to adjust the <span class="el_inlineCode">width</span> each time at nesting from the transplant, since the numerical value does not enter the name, the risk of collapse is also reduced.
              </p>
              <iframe class="el_iframe js_iframe" src="/sample/elementModule2.html"></iframe>
              
              
  <div class="bl_codeBlock">
    <em class="bl_codeBlock_ttl">Recommended(HTML)</em>
    <pre class="brush:html; class-name:''; highlight:[2,3,7,8]">
      
                &lt;header class=&#34;ly_header cf&#34;&gt;
                  &lt;!-- nest from the transplant --&gt;
                  &lt;a href=&#34;&#34; class=&#34;el_btn el_btn__orange&#34;&gt;.el_btn__orange&lt;br&gt;(nested)&lt;/a&gt;
                &lt;/header&gt;

                &lt;div class=&#34;ly_main&#34;&gt;
                  &lt;!-- modifier --&gt;
                  &lt;a href=&#34;&#34; class=&#34;el_btn el_btn__w100p el_btn__orange&#34;&gt;.el_btn__w100p&lt;/a&gt;
                &lt;/div&gt;
    </pre>
  </div>
  <!-- /.bl_codeBlock -->


              
              
  <div class="bl_codeBlock">
    <em class="bl_codeBlock_ttl">Recommended(CSS)</em>
    <pre class="brush:css; class-name:''; highlight:[]">
      
                .el_btn {
                  //nest from the transplant
                  .ly_header &gt; &amp; {
                    float: right;
                    margin: 0 20px 0 0;
                  }
                  //modifier
                  &amp;.el_btn__w100p {
                    width: 100%;
                    max-width: 100%;
                  }
                }
    </pre>
  </div>
  <!-- /.bl_codeBlock -->

            </section>
            <!-- /.bl_sectBlock4 -->
          </section>
          <!-- /.bl_sectBlock3 -->

          <section id="modifier" class="bl_sectBlock3">
            <h4 class="el_ttl3">3-3.Modifier</h4>
            <p class="el_sectTxt">
              <em class="el_note2">Naming convention: [base class name]__[modifier name]</em><br>
              Although I mention it several times already,
            </p>
            <ul class="bl_simpleList">
              <li>It looks different</li>
              <li>Changes in size (mainly element modules, child elements of block modules)</li>
              <li>Style changes according to certain rules (column etc)</li>
            </ul>
            <p class="el_sectTxt">
                In case PRECSS overwrites with modifier, we denote the modifier name with two underscores.
                Many are used in module groups, but of course it is also possible to use them for layout groups etc. depending on the situation.
                As a precaution, when overwriting a style with a modifier, <em class="el_caution">basically it is overwritten with multiple classes to increase the level of detail.</em>
                "Overwriting a style" is an intentional action, and if it is, it is not preferable that the style changes in CSS reading order.
            </p>
            <section id="modifier_element" class="bl_sectBlock4"><h5 class="el_ttl4">Element module example</h5>
              
              
  <div class="bl_codeBlock">
    <em class="bl_codeBlock_ttl">Not recommended</em>
    <pre class="brush:css; class-name:'light'; highlight:[]">
      
                  .el_btn__orange {
                    background-color: orange;
                  }
                  .el_btn {
                    background-color: white;
                  }
                  //applicable color: white
                  //The modifier does not work when the load order of styles has changed for some reason
    </pre>
  </div>
  <!-- /.bl_codeBlock -->

              
              
  <div class="bl_codeBlock">
    <em class="bl_codeBlock_ttl">Recommended</em>
    <pre class="brush:css; class-name:''; highlight:[]">
      
                  .el_btn {
                    background-color: white;
                  }
                  .el_btn.el_btn__orange {
                    background-color: orange;
                  }
    </pre>
  </div>
  <!-- /.bl_codeBlock -->

            </section>
            <!-- /.bl_sectBlock4 -->

            <section id="modifier_block" class="bl_sectBlock4">
              <h5 class="el_ttl4">Block module example</h5>
              <p class="el_sectTxt">
                  When applying modifier changes to child elements in a block module,
              </p>
              <ul class="bl_simpleList">
                <li>Apply a modifier only to a specific child element and overwrite the style</li>
                <li>Apply a modifier to the block module itself and override the child element style with nesting from the modifier</li>
              </ul>
              <p class="el_sectTxt">
                  There are two ways of you.
                  In the former case, by designating multiple classes as theory, in the latter case, specifying the child element by nesting from the modifier increases the detail level.
              </p>
              <iframe class="el_iframe js_iframe" src="/sample/modifier.html"></iframe>
              
              
  <div class="bl_codeBlock">
    <em class="bl_codeBlock_ttl">HTML</em>
    <pre class="brush:html; class-name:''; highlight:[11,12,17,18]">
      
                &lt;div class=&#34;bl_sectBlock&#34;&gt;
                  &lt;h2 class=&#34;bl_sectBlock_ttl&#34;&gt;.bl_sectBlock&lt;/h2&gt;

                  &lt;p class=&#34;bl_sectBlock_txt cf&#34;&gt;
                    &lt;!-- The original module --&gt;
                    &lt;img class=&#34;bl_sectBlock_txt_img&#34;&gt;
                    Lorem ipsum...
                  &lt;/p&gt;

                  &lt;p class=&#34;bl_sectBlock_txt cf&#34;&gt;
                    &lt;!-- Examples in which the behavior of only a part changes --&gt;
                    &lt;img class=&#34;bl_sectBlock_txt_img bl_sectBlock_txt_img__rev&#34;&gt;
                    Lorem ipsum...
                  &lt;/p&gt;
                &lt;/div&gt;

                &lt;!-- Example of overwriting styles for multiple child elements --&gt;
                &lt;div class=&#34;bl_sectBlock bl_sectBlock__sml&#34;&gt;
                  &lt;h3 class=&#34;bl_sectBlock_ttl&#34;&gt;.bl_sectBlock__sml&lt;/h3&gt;
                  &lt;p class=&#34;bl_sectBlock_txt cf&#34;&gt;
                    &lt;img class=&#34;bl_sectBlock_txt_img&#34;&gt;
                    Lorem ipsum...
                  &lt;/p&gt;
                &lt;/div&gt;
    </pre>
  </div>
  <!-- /.bl_codeBlock -->

              
              
  <div class="bl_codeBlock">
    <em class="bl_codeBlock_ttl">CSS</em>
    <pre class="brush:css; class-name:''; highlight:[]">
      
                //The original module
                .bl_sectBlock_txt_img {
                  float: left;
                  margin: 0 10px 10px 0;
                  //Examples in which the behavior of only a part changes
                  &amp;.bl_sectBlock_txt_img__rev {
                    float: right;
                    margin: 0 0 10px 10px;
                  }
                }

                //Example of overwriting styles for multiple child elements
                .bl_sectBlock {
                  &amp;.bl_sectBlock__sml {
                    &gt; .bl_sectBlock_ttl {
                      font-size: .8em;
                    }
                    &gt; .bl_sectBlock_txt {
                      font-size: .5em;
                    }
                    .bl_sectBlock_txt_img {
                      width: 5%;
                    }
                  }
                }
    </pre>
  </div>
  <!-- /.bl_codeBlock -->

              <p class="el_sectTxt">
                  Again, it is not recommended to add a modifier to the size change of the block module itself. Because it is dependent on the size of the transplant destination (in other words, the context), and the block module tends to be indefinite in variation as compared with the element module is.
                  The block module is often used in large size, so the risk of failure at the time of responsiveness is naturally higher than that of the element module.
                  If block modules are nested in other modules, we recommend overwriting styles with nesting from the porting module, not the modifier. (Details are explained in <a href="#advance">Advance Case</a> )
              </p>
            </section>
            <!-- /.bl_sectBlock4 -->
          </section>
          <!-- /.bl_sectBlock3 -->
        </section>
        <!-- /.bl_sectBlock2 -->

        <section id="helper" class="bl_sectBlock2">
          <h3 class="el_ttl2">4.Helper</h3>
          <p class="el_sectTxt">
            <em class="el_note2">Prefix: hp_</em>
          </p>
          <p class="el_sectTxt">
              hp stands for helper. Basically it's only one style, so add <span class="el_inlineCode">!Important</span> for intentional overwriting. Regarding the naming convention, we recommend that it conform to <a href="http://docs.emmet.io/cheat-sheet/" target="_blank">Emmet's cheat sheet</a> , and as other rules
          </p>
          <ul class="bl_simpleList">
            <li>In the case of units other than px, it is expressed in easy-to-understand initials</li>
            <li>Represent the decimal point with an underscore</li>
            <li>Negative values ​​express shorthand in capital letters</li>
            <li>If a character string follows a short hand, express it with a camel case</li>
          </ul>
          <p class="el_sectTxt">
              (These rules are also generally effective for naming modifiers.)
              However, if you use too much helper for one element, it will be no different from using the style attribute, so <em class="el_caution">if you have more than three helpers you should consider modularization.</em>
          </p>
          <p class="el_sectTxt">
              Basically only one style, allow <span class="el_inlineCode">outputStyle: compact</span> . It is also possible to process with more than one style with a helper, only if the behavior is limited and clear.
          </p>
          
          
  <div class="bl_codeBlock">
    <em class="bl_codeBlock_ttl">CSS</em>
    <pre class="brush:css; class-name:''; highlight:[]">
      
              .hp_db { display: block !important; }
              .hp_tac { text-align: center !important; }
              .hp_w400 { width: 400px !important; }
              .hp_w50p { width: 50% !important; }
              .hp_lh1_5 { line-height: 1.5 !important; }
              .hp_MT1e { margin-top: -1em !important; }
              .hp_bgcWhite { background-color: #fff !important; }

              //Example of one or more styles
              .hp_centering {
                display: block !important;
                margin-left: auto !important;
                margin-right: auto !important;
              }
    </pre>
  </div>
  <!-- /.bl_codeBlock -->

          <section id="helper_clearfix" class="bl_sectBlock3">
            <h5 class="el_ttl3">About clearfix</h5>
            <p class="el_sectTxt">
                In PRECSS, clearfix is ​​recommended for releasing float. This is to avoid challenging to describe styles unrelated to the original purpose only for float release.
                In particular, overflow is sometimes used for its original purpose, and it is not preferable that when you see only the CSS code, you do not know whether it is for float release or for original purpose.
                If you apply to PRECSS rules, you can also define clearfix as a helper, but clearfix itself is sufficiently general so you do not need to prefix it.
            </p>
          </section>
          <!-- /.bl_sectBlock3 -->
        </section>
        <!-- /.bl_sectBlock2 -->

        <section id="unique" class="bl_sectBlock2">
          <h3 class="el_ttl2">5.Unique</h3>
          <p class="el_sectTxt">
              <em class="el_note2">Prefix: un_</em>
            </p>
          <p class="el_sectTxt">
              It is a group that clarifies that it is used only for one page.
              Since it is only used on that page, it becomes a landmark to edit the style without worrying about the influence range in repair or operation.
              The size of the module is also free. It can be small or large.
          </p>
          <p class="el_sectTxt">
              For example, it is good to use it on a special page such as <a href="/" target="_blank">PRECSS's front page</a> , and it is also good to use it in places that are out of module design even in normal pages.
              In other words, unique groups are a versatile workaround for every irregular.
              If you get confused, please use a unique group for the time being. Anytime, any time, it is a good landmark to rework.
              However, remember that it is a measure for irregularities to the last because it is not expandable if you abuse it too much.
          </p>
          <p class="el_sectTxt">
              It would also be better to leave a comment on CSS for which page you are using.
          </p>
          
  <div class="bl_codeBlock">
    <em class="bl_codeBlock_ttl">HTML</em>
    <pre class="brush:html; class-name:''; highlight:[]">
      
              &lt;div class=&#34;un_siteRoot_wrapper&#34;&gt;
                &lt;section class=&#34;un_siteRoot&#34;&gt;
                  &lt;p class=&#34;un_siteRoot_logo&#34;&gt;&lt;img src=&#34;images/icon.svg&#34; alt=&#34;PRECSS logo&#34;&gt;&lt;/p&gt;
                  &lt;h1 class=&#34;un_siteRoot_ttl&#34;&gt;PRECSS&lt;/h1&gt;
                  &lt;p class=&#34;un_siteRoot_link&#34;&gt;&lt;span class=&#34;is_deactive&#34;&gt;English&lt;/span&gt; / &lt;a href=&#34;/ja/&#34;&gt;日本語&lt;/a&gt;&lt;/p&gt;
                &lt;/section&gt;
              &lt;/div&gt;
    </pre>
  </div>
  <!-- /.bl_codeBlock -->

          
          
  <div class="bl_codeBlock">
    <em class="bl_codeBlock_ttl">Recommended(CSS)</em>
    <pre class="brush:css; class-name:''; highlight:[]">
      
              //toppage
              .un_siteRoot_wrapper {
                position: relative;
                top: 33vh;
                text-align: center;
              }
              .un_siteRoot {
                display: inline-block;
              }...
    </pre>
  </div>
  <!-- /.bl_codeBlock -->

        </section>
        <!-- /.bl_sectBlock2 -->

        <section id="program" class="bl_sectBlock2">
          <h3 class="el_ttl2">6.Progoram</h3>
          <p class="el_sectTxt">
              In PRECSS, when touching elements with a program such as JavaScript, we recommend adding a special class as much as possible and separating it from the class for CSS.
          </p>
          <p class="el_sectTxt">
              <em class="el_note2">Prefix: js_</em>
            </p>
            <p class="el_sectTxt">
                It is a class for getting elements in JavaScript.
            </p>
          <p class="el_sectTxt">
              <em class="el_note2">Prefix: is_</em>
            </p>
          <p class="el_sectTxt">
              Class for managing state of element. Overwriting is done in multiple classes as well as in the case of modifiers, as it is always a style that must be applied, we can also use <span class="el_inlineCode">!Important</span> .
              State naming can be described simply as <span class="el_inlineCode">is_active</span> , but it is necessary <em class="el_caution">to apply styles with multiple classes</em> so that it does not affect other parts as well.
            <span class="el_note">* Depending on compatible browsers and circumstances, it is also recommended to add custom data attributes instead of JavaScript classes.</span>
          </p>
          
  <div class="bl_codeBlock">
    <em class="bl_codeBlock_ttl">HTML</em>
    <pre class="brush:html; class-name:''; highlight:[]">
      
              &lt;div class=&#34;bl_sectBlock js_accordion&#34;&gt;
                &lt;h3 class=&#34;bl_sectBlock_ttl js_accordion_head&#34;&gt;Title Here&lt;/h3&gt;
                &lt;p class=&#34;bl_sectBlock_txt js_accordion_body is_active&#34;&gt;
                  Lorem ipsum...
                &lt;/p&gt;
              &lt;/div&gt;
    </pre>
  </div>
  <!-- /.bl_codeBlock -->

          
          
  <div class="bl_codeBlock">
    <em class="bl_codeBlock_ttl">Not recommended(CSS)</em>
    <pre class="brush:css; class-name:'light'; highlight:[5]">
      
              .js_accordion_body {
                display: none;
              }
              //There is a possibility that it may affect other parts
              .is_active {
                display: block;
              }
    </pre>
  </div>
  <!-- /.bl_codeBlock -->

          
          
  <div class="bl_codeBlock">
    <em class="bl_codeBlock_ttl">Recommended(CSS)</em>
    <pre class="brush:css; class-name:''; highlight:[4]">
      
              .js_accordion_body {
                display: none;
              }
              .js_accordion_body.is_active {
                display: block;
              }
    </pre>
  </div>
  <!-- /.bl_codeBlock -->

        </section>
        <!-- /.bl_sectBlock2 -->

        <section id="original" class="bl_sectBlock2">
          <h3 class="el_ttl2">7.Original</h3>
          <p class="el_sectTxt">
              In addition, it is a feature of PRECSS that you can flexibly add a prefix according to the construction philosophy of the site.
              For example, when building the original grid layout, you can add a prefix such as <span class="el_inlineCode">.gr_4</span> , <span class="el_inlineCode">.gr_6</span> or <span class="el_inlineCode">.cl_4</span> , <span class="el_inlineCode">.cl_6</span> as abbreviation for grid.
              For smartphones only valid classes should be <span class="el_inlineCode">.sp_**</span> , tablet only valid classes should be <span class="el_inlineCode">.tb_**</span> .
              As long as it complies with certain rules, PRECSS accepts whatever you do.
          </p>
        </section>
        <!-- /.bl_sectBlock2 -->
      </section>
      <!-- /.bl_sectBlock -->
    </div>
    <!-- /.ly_main_inner -->
  </div>
  <!-- /.ly_main -->

  <div class="bl_sectBlockCalm">
    <p class="bl_sectBlockCalm_txt">Advance Case</p>
  </div>
  <!-- /.bl_sectBlockCalm -->

  <div class="ly_main">
    <div class="ly_main_inner">
      <section id="nestedModule" class="bl_sectBlock">
        <h2 class="el_ttl">When modules are nested in other modules</h2>
        <p class="el_sectTxt">
            In PRECSS, other block modules or element modules may be nested within one block module. This is the behavior under the idea that the module is "portable."
            We will show some guidelines mainly concerning layout problems, which we face in that case.
            Let's assume that the module that is currently being built is A, has already been built elsewhere, and B is the module you want to port to A.
            There are only two basic principles below.
        </p>
        <ul class="bl_simpleList">
          <li>he layout of B is controlled by nesting from A <br>
            (Child selector specification is preferable, but descendant selectors are allowed depending on circumstances)</li>
          <li>Child elements in B should not be controlled by nesting from A</li>
        </ul>
        <iframe class="el_iframe js_iframe" src="/sample/advance.html"></iframe>
        
        
  <div class="bl_codeBlock">
    <em class="bl_codeBlock_ttl">HTML</em>
    <pre class="brush:html; class-name:''; highlight:[16,17,18,19]">
      
          &lt;div class=&#34;ly_side&#34;&gt;
            &lt;!-- B module --&gt;
            &lt;div class=&#34;bl_imgBlock&#34;&gt;
              &lt;h3 class=&#34;bl_imgBlock_ttl&#34;&gt;.bl_imgBlock&lt;/h3&gt;
              &lt;p class=&#34;bl_imgBlock_img&#34;&gt;&lt;img src=&#34;//goo.gl/15naui&#34;&gt;&lt;/p&gt;
              &lt;p class=&#34;bl_imgBlock_txt&#34;&gt;
                Lorem ipsum...
              &lt;/p&gt;
            &lt;/div&gt;
          &lt;/div&gt;

          &lt;div class=&#34;ly_main&#34;&gt;
            &lt;!-- A module --&gt;
            &lt;div class=&#34;bl_sectBlock cf&#34;&gt;
              &lt;h2 class=&#34;bl_sectBlock_ttl&#34;&gt;.bl_sectBlock&lt;/h2&gt;
              &lt;!-- Porting B module --&gt;
              &lt;div class=&#34;bl_imgBlock&#34;&gt;
                ...
              &lt;/div&gt;
              &lt;p class=&#34;bl_sectBlock_txt&#34;&gt;
                Lorem ipsum...
              &lt;/p&gt;
            &lt;/div&gt;
          &lt;/div&gt;
    </pre>
  </div>
  <!-- /.bl_codeBlock -->

        
        
  <div class="bl_codeBlock">
    <em class="bl_codeBlock_ttl">CSS</em>
    <pre class="brush:css; class-name:''; highlight:[]">
      
          //B module
          .bl_imgBlock{
            margin: 0 0 20px 0;
          }

          //Port B module to A module
          .bl_sectBlock{
            &gt; .bl_imgBlock{
              width: 25%;
              float: left;
              margin: 0 10px 10px 0;
            }
          }
    </pre>
  </div>
  <!-- /.bl_codeBlock -->


        <p class="el_sectTxt">
            I will explain in detail about the second "child elements in B should not be controlled by nesting from A".
        </p>
        <p class="el_sectTxt">
            Do not overwrite the style in the form of <span class="el_inlineCode">A > B > child element</span> if you need something to change the child element of B when porting B to A.
            This is because the module block itself is an idea of ​​a <em class="el_caution">single chunk that is completed by itself.</em> It is possible to change the behavior of the chunk itself by the context of the porting module, but it is not preferable that even the child elements are influenced by the context.
            Without being afraid of misunderstanding, the B module itself can be controlled from the A module, but the sense that it should be hidden inside the B module.
            Changes within the block module are to be completed within the block module, <em class="el_caution">so the inside of the block module is a sanctuary which is not subject to change from other than the block module .</em>
        </p>
        <p class="el_sectTxt">
            As a matter of fact, if it is necessary to change in the B module at the time of incorporation into the A module, it is processed by adding a modifier to the B module.
            Here, we show an example where the content becomes small overall when the B module is ported to the A module.
        </p>
        <iframe class="el_iframe js_iframe" src="/sample/advance2.html"></iframe>
        
        
  <div class="bl_codeBlock">
    <em class="bl_codeBlock_ttl">HTML</em>
    <pre class="brush:html; class-name:''; highlight:[5,6,7,8]">
      
          &lt;div class=&#34;ly_main&#34;&gt;
            &lt;!-- A module --&gt;
            &lt;div class=&#34;bl_sectBlock cf&#34;&gt;
              &lt;h2 class=&#34;bl_sectBlock_ttl&#34;&gt;.bl_sectBlock&lt;/h2&gt;
              &lt;!-- Porting of B module, addition of bl_imgBlock__sml modifier --&gt;
              &lt;div class=&#34;bl_imgBlock bl_imgBlock__sml&#34;&gt;
                ...
              &lt;/div&gt;
              &lt;p class=&#34;bl_sectBlock_txt&#34;&gt;
                Lorem ipsum...
              &lt;/p&gt;
            &lt;/div&gt;
          &lt;/div&gt;
    </pre>
  </div>
  <!-- /.bl_codeBlock -->

        
        
  <div class="bl_codeBlock">
    <em class="bl_codeBlock_ttl">CSS</em>
    <pre class="brush:css; class-name:''; highlight:[]">
      
          //Addition of bl_imgBlock__sml modifier to B module
          .bl_imgBlock{
            &amp;.bl_imgBlock__sml{
              &gt; .bl_imgBlock_ttl{
                margin: 0 0 5px 0;
                font-size: .8em;
              }
              &gt; .bl_imgBlock_img{
                margin: 0 0 5px 0;
                &gt; img{
                  max-width: 80px;
                }
              }
              .bl_imgBlock_txt{
                margin: 0 0 10px 0;
                font-size: .8em;
              }
            }
          }
    </pre>
  </div>
  <!-- /.bl_codeBlock -->

        <p class="el_sectTxt">
            By describing like this, it protects the sanctuary of the block module and not only maintains a clear code of the maintenance scope, it becomes a versatile module that can reproduce the same state regardless of the context when porting to another place I will.
        </p>

        <section id="modifyAchild" class="bl_sectBlock2">
          <h3 class="el_ttl2">Changes in child elements of module A</h3>
          <p class="el_sectTxt">
              When B module is ported to A module, in some cases, there may be changes to the child elements of module A.
I will illustrate three possible patterns as an approach in that case.
          </p>
        <ul class="bl_simpleList">
          <li>Modify the style by adding a modifier directly to the corresponding child element module of A</li>
          <li>Modifier is added to A module and style is changed by nest designation</li>
          <li>Create an A2 module that is similar to the A module, separated from the original A module</li>
        </ul>
        <p class="el_sectTxt">
            Depending on how far you are looking for extensibility, the first thing to recommend a conclusion earlier is <em class="el_caution">to create a third "similar A2 module" .</em>
            For example , let's explain the pattern where <span class="el_inlineCode">bl_imgBlock</span> and <span class="el_inlineCode">bl_sectBlock_txt</span> are displayed horizontally almost equally side by side.
        </p>
        <iframe class="el_iframe js_iframe" src="/sample/advance3.html"></iframe>
        <section id="modifyAchild_1" class="bl_sectBlock3">
          <h4 class="el_ttl3">Modify the style by adding a modifier directly to the corresponding child element module of A</h4>
          
          
  <div class="bl_codeBlock">
    <em class="bl_codeBlock_ttl">HTML</em>
    <pre class="brush:html; class-name:''; highlight:[6,7]">
      
            &lt;div class=&#34;bl_sectBlock cf&#34;&gt;
              &lt;h2 class=&#34;bl_sectBlock_ttl&#34;&gt;.bl_sectBlock&lt;/h2&gt;
              &lt;div class=&#34;bl_imgBlock&#34;&gt;
                ...
              &lt;/div&gt;
              &lt;!-- Adding a modifier to the child element module --&gt;
              &lt;p class=&#34;bl_sectBlock_txt bl_sectBlock_txt__r49p&#34;&gt;
                ...
              &lt;/p&gt;
            &lt;/div&gt;
    </pre>
  </div>
  <!-- /.bl_codeBlock -->

          
          
  <div class="bl_codeBlock">
    <em class="bl_codeBlock_ttl">CSS</em>
    <pre class="brush:css; class-name:''; highlight:[8]">
      
              .bl_sectBlock{
                &gt; .bl_imgBlock{
                  width: 49%;
                  float: left;
                }
              }
              .bl_sectBlock_txt{
                &amp;.bl_sectBlock_txt__r49p{
                  float: right;
                  width: 49%;
                }
              }
    </pre>
  </div>
  <!-- /.bl_codeBlock -->

          <p class="el_sectTxt">
              This pattern is the fastest, but if you can only adjust the corresponding module with the modifier, and you need to adjust other modules as well, you will have to add modifiers every time, so it's somewhat extensible I lack it.
          </p>
        </section>
        <!-- /.bl_sectBlock3 -->

        <section id="modifyAchild_2" class="bl_sectBlock3">
          <h4 class="el_ttl3">Modifier is added to A module and style is changed by nest designation</h4>
          
          
  <div class="bl_codeBlock">
    <em class="bl_codeBlock_ttl">HTML</em>
    <pre class="brush:html; class-name:''; highlight:[1,2]">
      
            &lt;!-- Adding a modifier to A module --&gt;
            &lt;div class=&#34;bl_sectBlock bl_sectBlock__hasImgBlock cf&#34;&gt;
              &lt;h2 class=&#34;bl_sectBlock_ttl&#34;&gt;.bl_sectBlock&lt;/h2&gt;
              &lt;div class=&#34;bl_imgBlock&#34;&gt;
                ...
              &lt;/div&gt;
              &lt;p class=&#34;bl_sectBlock_txt&#34;&gt;
                ...
              &lt;/p&gt;
            &lt;/div&gt;
    </pre>
  </div>
  <!-- /.bl_codeBlock -->

          
          
  <div class="bl_codeBlock">
    <em class="bl_codeBlock_ttl">CSS</em>
    <pre class="brush:css; class-name:''; highlight:[]">
      
            .bl_sectBlock.bl_sectBlock__hasImgBlock{
              &gt; .bl_imgBlock{
                width: 49%;
                float: left;
              }
              &gt; .bl_sectBlock_txt{
                float: right;
                width: 49%;
              }
            }
    </pre>
  </div>
  <!-- /.bl_codeBlock -->

          <p class="el_sectTxt">
              Compared to the above, this pattern only adjusts CSS even if it is necessary to adjust other child elements as well.
              For modifier names, it is a good idea to set <span class="el_inlineCode">bl_sectBlock__hasImgBlock</span> , whose name is not influenced by the state of child elements, considering extensibility.
              However, this time it is enough because there is only one nested block module, but if there are more modules to be nested in the A module, for example, in addition to B a C module is also incorporated in the A module, the modifier name is redundant It is expected to become.
          </p>
          <p class="el_sectTxt">
              In addition, if you make it a modifier name of <span class="el_inlineCode">**__has**</span> , it is more administrative to make the style specification for B module nested from the modifier as in the case of the above CSS example, but if it is assumed to be an example at the beginning When coexisting with "nest of B module not affecting the child elements of A", <em class="el_caution">"both contain B module, but <span class="el_inlineCode">**__has**</span> modifier is added only to one side"</em> , and again It will cause a lot of collapse logically.
          </p>
        </section>
        <!-- /.bl_sectBlock3 -->

        <section id="modifyAchild_3" class="bl_sectBlock3">
          <h4 class="el_ttl3">Create an A2 module that is similar to the A module, separated from the original A module</h4>
          
          
  <div class="bl_codeBlock">
    <em class="bl_codeBlock_ttl">HTML</em>
    <pre class="brush:html; class-name:''; highlight:[]">
      
              &lt;div class=&#34;bl_sectBlock2 cf&#34;&gt;
                &lt;h2 class=&#34;bl_sectBlock2_ttl&#34;&gt;.bl_sectBlock2&lt;/h2&gt;
                &lt;div class=&#34;bl_imgBlock&#34;&gt;
                  ...
                &lt;/div&gt;
                &lt;p class=&#34;bl_sectBlock2_txt&#34;&gt;
                  ...
                &lt;/p&gt;
              &lt;/div&gt;
    </pre>
  </div>
  <!-- /.bl_codeBlock -->

          
          
  <div class="bl_codeBlock">
    <em class="bl_codeBlock_ttl">CSS</em>
    <pre class="brush:css; class-name:''; highlight:[]">
      
              //Bulk specification of overlapping style
              .bl_sectBlock,
              .bl_sectBlock2 {...}
              .bl_sectBlock_ttl,
              .bl_sectBlock2_ttl {...}
              .bl_sectBlock_txt_img,
              .bl_sectBlock2_txt_img {...}

              //bl_sectBlock unique specification
              .bl_sectBlock_txt {...}

              //bl_sectBlock2 unique specification
              .bl_sectBlock2_txt {
                width: 49%;
                float: right;
              }
              .bl_sectBlock2 &gt; .bl_imgBlock {
                float: left;
                width: 49%;
              }
    </pre>
  </div>
  <!-- /.bl_codeBlock -->

          <p class="el_sectTxt">
              It adds serial numbers and creates another module as a variant of the original module. Applying the same style again for parts that do not change is a bit of a hassle, but manageability and extensibility are quite high because it can be separated from the original A module.
              In this example, selectors are separated by commas, but of course it is also possible to manage using CSS preprocessor extend and mixin.
              If you want to centrally manage common parts such as the title part in the same class by all means, there is a way to make it into an element module.
          </p>
        </section>
        <!-- /.bl_sectBlock3 -->
        </section>
        <!-- /.bl_sectBlock2 -->
      </section>
      <!-- /.bl_sectBlock -->
    </div>
    <!-- /.ly_main_inner -->
  </div>
  <!-- /.ly_main -->
</article>

<footer class="ly_footer">
  <div class="ly_footer_inner">
    <p class="el_centerTxt">
      PRECSS is maintained and funded by assialiholic, translated by Google Translate.<br>
      Contributors &amp; Transrators wanted!<br>
      <a href="//github.com/assialiholic/precss/" target="_blank"><i class="fab fa-github fa-3x" aria-hidden="true"></i></a>
    </p>
  </div>
  <!-- /.ly_footer_inner -->
</footer>

<script src="http://cdn.jsdelivr.net/jquery/1.8.3/jquery-1.8.3.min.js"></script>
<script src="/js/scripts.js"></script>
</body>
</html>
